import {
  esm_exports2 as esm_exports,
  formatJsonRpcError,
  isLocalhostUrl,
  isWsUrl,
  parseConnectionError,
  require_browser,
  safeJsonParse,
  safeJsonStringify
} from "./chunk-PE5I4252.js";
import {
  require_events
} from "./chunk-NPY75PGV.js";
import {
  __toESM
} from "./chunk-ONY6HBPH.js";

// node_modules/@walletconnect/jsonrpc-ws-connection/dist/index.es.js
var import_events = __toESM(require_events());
var v = () => typeof WebSocket < "u" ? WebSocket : typeof global < "u" && typeof global.WebSocket < "u" ? global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require_browser();
var w = () => typeof WebSocket < "u" || typeof global < "u" && typeof global.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u";
var d = (r) => r.split("?")[0];
var h = 10;
var b = v();
var f = class {
  constructor(e) {
    if (this.url = e, this.events = new import_events.EventEmitter(), this.registering = false, !isWsUrl(e)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    this.url = e;
  }
  get connected() {
    return typeof this.socket < "u";
  }
  get connecting() {
    return this.registering;
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async open(e = this.url) {
    await this.register(e);
  }
  async close() {
    return new Promise((e, t) => {
      if (typeof this.socket > "u") {
        t(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (n) => {
        this.onClose(n), e();
      }, this.socket.close();
    });
  }
  async send(e) {
    typeof this.socket > "u" && (this.socket = await this.register());
    try {
      this.socket.send(safeJsonStringify(e));
    } catch (t) {
      this.onError(e.id, t);
    }
  }
  register(e = this.url) {
    if (!isWsUrl(e)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    if (this.registering) {
      const t = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= t || this.events.listenerCount("open") >= t) && this.events.setMaxListeners(t + 1), new Promise((n, s) => {
        this.events.once("register_error", (o) => {
          this.resetMaxListeners(), s(o);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.socket > "u") return s(new Error("WebSocket connection is missing or invalid"));
          n(this.socket);
        });
      });
    }
    return this.url = e, this.registering = true, new Promise((t, n) => {
      const s = (0, esm_exports.isReactNative)() ? void 0 : { rejectUnauthorized: !isLocalhostUrl(e) }, o = new b(e, [], s);
      w() ? o.onerror = (i) => {
        const a = i;
        n(this.emitError(a.error));
      } : o.on("error", (i) => {
        n(this.emitError(i));
      }), o.onopen = () => {
        this.onOpen(o), t(o);
      };
    });
  }
  onOpen(e) {
    e.onmessage = (t) => this.onPayload(t), e.onclose = (t) => this.onClose(t), this.socket = e, this.registering = false, this.events.emit("open");
  }
  onClose(e) {
    this.socket = void 0, this.registering = false, this.events.emit("close", e);
  }
  onPayload(e) {
    if (typeof e.data > "u") return;
    const t = typeof e.data == "string" ? safeJsonParse(e.data) : e.data;
    this.events.emit("payload", t);
  }
  onError(e, t) {
    const n = this.parseError(t), s = n.message || n.toString(), o = formatJsonRpcError(e, s);
    this.events.emit("payload", o);
  }
  parseError(e, t = this.url) {
    return parseConnectionError(e, d(t), "WS");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > h && this.events.setMaxListeners(h);
  }
  emitError(e) {
    const t = this.parseError(new Error((e == null ? void 0 : e.message) || `WebSocket connection failed for host: ${d(this.url)}`));
    return this.events.emit("register_error", t), t;
  }
};

export {
  f
};
//# sourceMappingURL=chunk-HWJRX7OM.js.map
