import {
  useMutation,
  useQuery,
  useQueryClient
} from "./chunk-LS4JEWJI.js";
import {
  Address,
  CHAIN_IDS,
  Contract,
  Fuel,
  Provider,
  TransactionResponse
} from "./chunk-RRLYV7K7.js";
import "./chunk-NPY75PGV.js";
import "./chunk-SKMNXGXP.js";
import {
  require_react_dom
} from "./chunk-Z2GUPSCO.js";
import {
  require_jsx_runtime
} from "./chunk-TLG7CTPL.js";
import {
  require_react
} from "./chunk-VT65UQWK.js";
import {
  __toESM
} from "./chunk-ONY6HBPH.js";

// node_modules/@fuels/react/dist/index.mjs
var import_react4 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-dialog/dist/index.mjs
var React25 = __toESM(require_react(), 1);

// node_modules/@radix-ui/primitive/dist/index.mjs
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler == null ? void 0 : originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler == null ? void 0 : ourEventHandler(event);
    }
  };
}

// node_modules/@radix-ui/react-compose-refs/dist/index.mjs
var React = __toESM(require_react(), 1);
function setRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => refs.forEach((ref) => setRef(ref, node));
}
function useComposedRefs(...refs) {
  return React.useCallback(composeRefs(...refs), refs);
}

// node_modules/@radix-ui/react-context/dist/index.mjs
var React2 = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
function createContext2(rootComponentName, defaultContext) {
  const Context = React2.createContext(defaultContext);
  function Provider2(props) {
    const { children, ...context } = props;
    const value = React2.useMemo(() => context, Object.values(context));
    return (0, import_jsx_runtime.jsx)(Context.Provider, { value, children });
  }
  function useContext22(consumerName) {
    const context = React2.useContext(Context);
    if (context) return context;
    if (defaultContext !== void 0) return defaultContext;
    throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
  }
  Provider2.displayName = rootComponentName + "Provider";
  return [Provider2, useContext22];
}
function createContextScope(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext32(rootComponentName, defaultContext) {
    const BaseContext = React2.createContext(defaultContext);
    const index = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    function Provider2(props) {
      const { scope, children, ...context } = props;
      const Context = (scope == null ? void 0 : scope[scopeName][index]) || BaseContext;
      const value = React2.useMemo(() => context, Object.values(context));
      return (0, import_jsx_runtime.jsx)(Context.Provider, { value, children });
    }
    function useContext22(consumerName, scope) {
      const Context = (scope == null ? void 0 : scope[scopeName][index]) || BaseContext;
      const context = React2.useContext(Context);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    Provider2.displayName = rootComponentName + "Provider";
    return [Provider2, useContext22];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return React2.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = (scope == null ? void 0 : scope[scopeName]) || scopeContexts;
      return React2.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
        [scope, contexts]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [createContext32, composeContextScopes(createScope, ...createContextScopeDeps)];
}
function composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return React2.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}

// node_modules/@radix-ui/react-id/dist/index.mjs
var React4 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-use-layout-effect/dist/index.mjs
var React3 = __toESM(require_react(), 1);
var useLayoutEffect2 = Boolean(globalThis == null ? void 0 : globalThis.document) ? React3.useLayoutEffect : () => {
};

// node_modules/@radix-ui/react-id/dist/index.mjs
var useReactId = React4["useId".toString()] || (() => void 0);
var count = 0;
function useId(deterministicId) {
  const [id, setId] = React4.useState(useReactId());
  useLayoutEffect2(() => {
    if (!deterministicId) setId((reactId) => reactId ?? String(count++));
  }, [deterministicId]);
  return deterministicId || (id ? `radix-${id}` : "");
}

// node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
var React6 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-use-callback-ref/dist/index.mjs
var React5 = __toESM(require_react(), 1);
function useCallbackRef(callback) {
  const callbackRef = React5.useRef(callback);
  React5.useEffect(() => {
    callbackRef.current = callback;
  });
  return React5.useMemo(() => (...args) => {
    var _a;
    return (_a = callbackRef.current) == null ? void 0 : _a.call(callbackRef, ...args);
  }, []);
}

// node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
function useControllableState({
  prop,
  defaultProp,
  onChange = () => {
  }
}) {
  const [uncontrolledProp, setUncontrolledProp] = useUncontrolledState({ defaultProp, onChange });
  const isControlled = prop !== void 0;
  const value = isControlled ? prop : uncontrolledProp;
  const handleChange = useCallbackRef(onChange);
  const setValue = React6.useCallback(
    (nextValue) => {
      if (isControlled) {
        const setter = nextValue;
        const value2 = typeof nextValue === "function" ? setter(prop) : nextValue;
        if (value2 !== prop) handleChange(value2);
      } else {
        setUncontrolledProp(nextValue);
      }
    },
    [isControlled, prop, setUncontrolledProp, handleChange]
  );
  return [value, setValue];
}
function useUncontrolledState({
  defaultProp,
  onChange
}) {
  const uncontrolledState = React6.useState(defaultProp);
  const [value] = uncontrolledState;
  const prevValueRef = React6.useRef(value);
  const handleChange = useCallbackRef(onChange);
  React6.useEffect(() => {
    if (prevValueRef.current !== value) {
      handleChange(value);
      prevValueRef.current = value;
    }
  }, [value, prevValueRef, handleChange]);
  return uncontrolledState;
}

// node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
var React10 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-primitive/dist/index.mjs
var React8 = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);

// node_modules/@radix-ui/react-slot/dist/index.mjs
var React7 = __toESM(require_react(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var Slot = React7.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  const childrenArray = React7.Children.toArray(children);
  const slottable = childrenArray.find(isSlottable);
  if (slottable) {
    const newElement = slottable.props.children;
    const newChildren = childrenArray.map((child) => {
      if (child === slottable) {
        if (React7.Children.count(newElement) > 1) return React7.Children.only(null);
        return React7.isValidElement(newElement) ? newElement.props.children : null;
      } else {
        return child;
      }
    });
    return (0, import_jsx_runtime2.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children: React7.isValidElement(newElement) ? React7.cloneElement(newElement, void 0, newChildren) : null });
  }
  return (0, import_jsx_runtime2.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children });
});
Slot.displayName = "Slot";
var SlotClone = React7.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  if (React7.isValidElement(children)) {
    const childrenRef = getElementRef(children);
    return React7.cloneElement(children, {
      ...mergeProps(slotProps, children.props),
      // @ts-ignore
      ref: forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef
    });
  }
  return React7.Children.count(children) > 1 ? React7.Children.only(null) : null;
});
SlotClone.displayName = "SlotClone";
var Slottable = ({ children }) => {
  return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children });
};
function isSlottable(child) {
  return React7.isValidElement(child) && child.type === Slottable;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          childPropValue(...args);
          slotPropValue(...args);
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef(element) {
  var _a, _b;
  let getter = (_a = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// node_modules/@radix-ui/react-primitive/dist/index.mjs
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
];
var Primitive = NODES.reduce((primitive, node) => {
  const Node = React8.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return (0, import_jsx_runtime3.jsx)(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node };
}, {});
function dispatchDiscreteCustomEvent(target, event) {
  if (target) ReactDOM.flushSync(() => target.dispatchEvent(event));
}

// node_modules/@radix-ui/react-use-escape-keydown/dist/index.mjs
var React9 = __toESM(require_react(), 1);
function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const onEscapeKeyDown = useCallbackRef(onEscapeKeyDownProp);
  React9.useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape") {
        onEscapeKeyDown(event);
      }
    };
    ownerDocument.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown, { capture: true });
  }, [onEscapeKeyDown, ownerDocument]);
}

// node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var DISMISSABLE_LAYER_NAME = "DismissableLayer";
var CONTEXT_UPDATE = "dismissableLayer.update";
var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
var originalBodyPointerEvents;
var DismissableLayerContext = React10.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var DismissableLayer = React10.forwardRef(
  (props, forwardedRef) => {
    const {
      disableOutsidePointerEvents = false,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      ...layerProps
    } = props;
    const context = React10.useContext(DismissableLayerContext);
    const [node, setNode] = React10.useState(null);
    const ownerDocument = (node == null ? void 0 : node.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document);
    const [, force] = React10.useState({});
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
    const layers = Array.from(context.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
    const index = node ? layers.indexOf(node) : -1;
    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = usePointerDownOutside((event) => {
      const target = event.target;
      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
      if (!isPointerEventsEnabled || isPointerDownOnBranch) return;
      onPointerDownOutside == null ? void 0 : onPointerDownOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    const focusOutside = useFocusOutside((event) => {
      const target = event.target;
      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
      if (isFocusInBranch) return;
      onFocusOutside == null ? void 0 : onFocusOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    useEscapeKeydown((event) => {
      const isHighestLayer = index === context.layers.size - 1;
      if (!isHighestLayer) return;
      onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    }, ownerDocument);
    React10.useEffect(() => {
      if (!node) return;
      if (disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
          ownerDocument.body.style.pointerEvents = "none";
        }
        context.layersWithOutsidePointerEventsDisabled.add(node);
      }
      context.layers.add(node);
      dispatchUpdate();
      return () => {
        if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
        }
      };
    }, [node, ownerDocument, disableOutsidePointerEvents, context]);
    React10.useEffect(() => {
      return () => {
        if (!node) return;
        context.layers.delete(node);
        context.layersWithOutsidePointerEventsDisabled.delete(node);
        dispatchUpdate();
      };
    }, [node, context]);
    React10.useEffect(() => {
      const handleUpdate = () => force({});
      document.addEventListener(CONTEXT_UPDATE, handleUpdate);
      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
    }, []);
    return (0, import_jsx_runtime4.jsx)(
      Primitive.div,
      {
        ...layerProps,
        ref: composedRefs,
        style: {
          pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
          ...props.style
        },
        onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),
        onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),
        onPointerDownCapture: composeEventHandlers(
          props.onPointerDownCapture,
          pointerDownOutside.onPointerDownCapture
        )
      }
    );
  }
);
DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
var BRANCH_NAME = "DismissableLayerBranch";
var DismissableLayerBranch = React10.forwardRef((props, forwardedRef) => {
  const context = React10.useContext(DismissableLayerContext);
  const ref = React10.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  React10.useEffect(() => {
    const node = ref.current;
    if (node) {
      context.branches.add(node);
      return () => {
        context.branches.delete(node);
      };
    }
  }, [context.branches]);
  return (0, import_jsx_runtime4.jsx)(Primitive.div, { ...props, ref: composedRefs });
});
DismissableLayerBranch.displayName = BRANCH_NAME;
function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handlePointerDownOutside = useCallbackRef(onPointerDownOutside);
  const isPointerInsideReactTreeRef = React10.useRef(false);
  const handleClickRef = React10.useRef(() => {
  });
  React10.useEffect(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = function() {
          handleAndDispatchCustomEvent(
            POINTER_DOWN_OUTSIDE,
            handlePointerDownOutside,
            eventDetail,
            { discrete: true }
          );
        };
        var handleAndDispatchPointerDownOutsideEvent = handleAndDispatchPointerDownOutsideEvent2;
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
        } else {
          handleAndDispatchPointerDownOutsideEvent2();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClickRef.current);
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [ownerDocument, handlePointerDownOutside]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function useFocusOutside(onFocusOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
  const handleFocusOutside = useCallbackRef(onFocusOutside);
  const isFocusInsideReactTreeRef = React10.useRef(false);
  React10.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [ownerDocument, handleFocusOutside]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function dispatchUpdate() {
  const event = new CustomEvent(CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });
  if (handler) target.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(target, event);
  } else {
    target.dispatchEvent(event);
  }
}

// node_modules/@radix-ui/react-focus-scope/dist/index.mjs
var React11 = __toESM(require_react(), 1);
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS = { bubbles: false, cancelable: true };
var FOCUS_SCOPE_NAME = "FocusScope";
var FocusScope = React11.forwardRef((props, forwardedRef) => {
  const {
    loop = false,
    trapped = false,
    onMountAutoFocus: onMountAutoFocusProp,
    onUnmountAutoFocus: onUnmountAutoFocusProp,
    ...scopeProps
  } = props;
  const [container, setContainer] = React11.useState(null);
  const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);
  const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);
  const lastFocusedElementRef = React11.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));
  const focusScope = React11.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  React11.useEffect(() => {
    if (trapped) {
      let handleFocusIn2 = function(event) {
        if (focusScope.paused || !container) return;
        const target = event.target;
        if (container.contains(target)) {
          lastFocusedElementRef.current = target;
        } else {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleFocusOut2 = function(event) {
        if (focusScope.paused || !container) return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null) return;
        if (!container.contains(relatedTarget)) {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleMutations2 = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body) return;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0) focus(container);
        }
      };
      var handleFocusIn = handleFocusIn2, handleFocusOut = handleFocusOut2, handleMutations = handleMutations2;
      document.addEventListener("focusin", handleFocusIn2);
      document.addEventListener("focusout", handleFocusOut2);
      const mutationObserver = new MutationObserver(handleMutations2);
      if (container) mutationObserver.observe(container, { childList: true, subtree: true });
      return () => {
        document.removeEventListener("focusin", handleFocusIn2);
        document.removeEventListener("focusout", handleFocusOut2);
        mutationObserver.disconnect();
      };
    }
  }, [trapped, container, focusScope.paused]);
  React11.useEffect(() => {
    if (container) {
      focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus(container);
          }
        }
      }
      return () => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) {
            focus(previouslyFocusedElement ?? document.body, { select: true });
          }
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
  const handleKeyDown = React11.useCallback(
    (event) => {
      if (!loop && !trapped) return;
      if (focusScope.paused) return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = document.activeElement;
      if (isTabKey && focusedElement) {
        const container2 = event.currentTarget;
        const [first, last] = getTabbableEdges(container2);
        const hasTabbableElementsInside = first && last;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container2) event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last) {
            event.preventDefault();
            if (loop) focus(first, { select: true });
          } else if (event.shiftKey && focusedElement === first) {
            event.preventDefault();
            if (loop) focus(last, { select: true });
          }
        }
      }
    },
    [loop, trapped, focusScope.paused]
  );
  return (0, import_jsx_runtime5.jsx)(Primitive.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });
});
FocusScope.displayName = FOCUS_SCOPE_NAME;
function focusFirst(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (document.activeElement !== previouslyFocusedElement) return;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates(container);
  const first = findVisible(candidates, container);
  const last = findVisible(candidates.reverse(), container);
  return [first, last];
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container) {
  for (const element of elements) {
    if (!isHidden(element, { upTo: container })) return element;
  }
}
function isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden") return true;
  while (node) {
    if (upTo !== void 0 && node === upTo) return false;
    if (getComputedStyle(node).display === "none") return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)
      element.select();
  }
}
var focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope == null ? void 0 : activeFocusScope.pause();
      }
      stack = arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      var _a;
      stack = arrayRemove(stack, focusScope);
      (_a = stack[0]) == null ? void 0 : _a.resume();
    }
  };
}
function arrayRemove(array, item) {
  const updatedArray = [...array];
  const index = updatedArray.indexOf(item);
  if (index !== -1) {
    updatedArray.splice(index, 1);
  }
  return updatedArray;
}
function removeLinks(items) {
  return items.filter((item) => item.tagName !== "A");
}

// node_modules/@radix-ui/react-portal/dist/index.mjs
var React12 = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var PORTAL_NAME = "Portal";
var Portal = React12.forwardRef((props, forwardedRef) => {
  var _a;
  const { container: containerProp, ...portalProps } = props;
  const [mounted, setMounted] = React12.useState(false);
  useLayoutEffect2(() => setMounted(true), []);
  const container = containerProp || mounted && ((_a = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _a.body);
  return container ? import_react_dom.default.createPortal((0, import_jsx_runtime6.jsx)(Primitive.div, { ...portalProps, ref: forwardedRef }), container) : null;
});
Portal.displayName = PORTAL_NAME;

// node_modules/@radix-ui/react-presence/dist/index.mjs
var React22 = __toESM(require_react(), 1);
var ReactDOM3 = __toESM(require_react_dom(), 1);
var React13 = __toESM(require_react(), 1);
function useStateMachine(initialState, machine) {
  return React13.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState);
}
var Presence = (props) => {
  const { present, children } = props;
  const presence = usePresence(present);
  const child = typeof children === "function" ? children({ present: presence.isPresent }) : React22.Children.only(children);
  const ref = useComposedRefs(presence.ref, getElementRef2(child));
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? React22.cloneElement(child, { ref }) : null;
};
Presence.displayName = "Presence";
function usePresence(present) {
  const [node, setNode] = React22.useState();
  const stylesRef = React22.useRef({});
  const prevPresentRef = React22.useRef(present);
  const prevAnimationNameRef = React22.useRef("none");
  const initialState = present ? "mounted" : "unmounted";
  const [state, send] = useStateMachine(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  React22.useEffect(() => {
    const currentAnimationName = getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [state]);
  useLayoutEffect2(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = getAnimationName(styles);
      if (present) {
        send("MOUNT");
      } else if (currentAnimationName === "none" || (styles == null ? void 0 : styles.display) === "none") {
        send("UNMOUNT");
      } else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating) {
          send("ANIMATION_OUT");
        } else {
          send("UNMOUNT");
        }
      }
      prevPresentRef.current = present;
    }
  }, [present, send]);
  useLayoutEffect2(() => {
    if (node) {
      const handleAnimationEnd = (event) => {
        const currentAnimationName = getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(event.animationName);
        if (event.target === node && isCurrentAnimation) {
          ReactDOM3.flushSync(() => send("ANIMATION_END"));
        }
      };
      const handleAnimationStart = (event) => {
        if (event.target === node) {
          prevAnimationNameRef.current = getAnimationName(stylesRef.current);
        }
      };
      node.addEventListener("animationstart", handleAnimationStart);
      node.addEventListener("animationcancel", handleAnimationEnd);
      node.addEventListener("animationend", handleAnimationEnd);
      return () => {
        node.removeEventListener("animationstart", handleAnimationStart);
        node.removeEventListener("animationcancel", handleAnimationEnd);
        node.removeEventListener("animationend", handleAnimationEnd);
      };
    } else {
      send("ANIMATION_END");
    }
  }, [node, send]);
  return {
    isPresent: ["mounted", "unmountSuspended"].includes(state),
    ref: React22.useCallback((node2) => {
      if (node2) stylesRef.current = getComputedStyle(node2);
      setNode(node2);
    }, [])
  };
}
function getAnimationName(styles) {
  return (styles == null ? void 0 : styles.animationName) || "none";
}
function getElementRef2(element) {
  var _a, _b;
  let getter = (_a = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// node_modules/@radix-ui/react-focus-guards/dist/index.mjs
var React14 = __toESM(require_react(), 1);
var count2 = 0;
function useFocusGuards() {
  React14.useEffect(() => {
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
    document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
    count2++;
    return () => {
      if (count2 === 1) {
        document.querySelectorAll("[data-radix-focus-guard]").forEach((node) => node.remove());
      }
      count2--;
    };
  }, []);
}
function createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none";
  return element;
}

// node_modules/react-remove-scroll/node_modules/tslib/tslib.es6.mjs
var __assign = function() {
  __assign = Object.assign || function __assign3(t) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar2; i < l; i++) {
    if (ar2 || !(i in from)) {
      if (!ar2) ar2 = Array.prototype.slice.call(from, 0, i);
      ar2[i] = from[i];
    }
  }
  return to.concat(ar2 || Array.prototype.slice.call(from));
}

// node_modules/react-remove-scroll/dist/es2015/Combination.js
var React24 = __toESM(require_react());

// node_modules/react-remove-scroll/dist/es2015/UI.js
var React19 = __toESM(require_react());

// node_modules/react-remove-scroll-bar/dist/es2015/constants.js
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";

// node_modules/use-callback-ref/dist/es2015/assignRef.js
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}

// node_modules/use-callback-ref/dist/es2015/useRef.js
var import_react = __toESM(require_react());
function useCallbackRef2(initialValue, callback) {
  var ref = (0, import_react.useState)(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}

// node_modules/use-callback-ref/dist/es2015/useMergeRef.js
var React15 = __toESM(require_react());
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? React15.useLayoutEffect : React15.useEffect;
var currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef2(defaultValue || null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef(ref, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}

// node_modules/use-sidecar/node_modules/tslib/tslib.es6.mjs
var __assign2 = function() {
  __assign2 = Object.assign || function __assign3(t) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
function __rest2(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}

// node_modules/use-sidecar/dist/es2015/hoc.js
var React16 = __toESM(require_react());

// node_modules/use-sidecar/dist/es2015/hook.js
var import_react2 = __toESM(require_react());

// node_modules/use-sidecar/dist/es2015/medium.js
function ItoI(a) {
  return a;
}
function innerCreateMedium(defaults, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x) {
          return x !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x) {
          return cb(x);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x) {
          pendingQueue.push(x);
          cycle();
        },
        filter: function(filter) {
          pendingQueue = pendingQueue.filter(filter);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign2({ async: true, ssr: false }, options);
  return medium;
}

// node_modules/use-sidecar/dist/es2015/renderProp.js
var React17 = __toESM(require_react());
var import_react3 = __toESM(require_react());

// node_modules/use-sidecar/dist/es2015/exports.js
var React18 = __toESM(require_react());
var SideCar = function(_a) {
  var sideCar = _a.sideCar, rest = __rest2(_a, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React18.createElement(Target, __assign2({}, rest));
};
SideCar.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar;
}

// node_modules/react-remove-scroll/dist/es2015/medium.js
var effectCar = createSidecarMedium();

// node_modules/react-remove-scroll/dist/es2015/UI.js
var nothing = function() {
  return;
};
var RemoveScroll = React19.forwardRef(function(props, parentRef) {
  var ref = React19.useRef(null);
  var _a = React19.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a[0], setCallbacks = _a[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? "div" : _b, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return React19.createElement(
    React19.Fragment,
    null,
    enabled && React19.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
    forwardProps ? React19.cloneElement(React19.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React19.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};

// node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var React23 = __toESM(require_react());

// node_modules/react-remove-scroll-bar/dist/es2015/component.js
var React21 = __toESM(require_react());

// node_modules/react-style-singleton/dist/es2015/hook.js
var React20 = __toESM(require_react());

// node_modules/get-nonce/dist/es2015/index.js
var currentNonce;
var getNonce = function() {
  if (currentNonce) {
    return currentNonce;
  }
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};

// node_modules/react-style-singleton/dist/es2015/singleton.js
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};

// node_modules/react-style-singleton/dist/es2015/hook.js
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    React20.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};

// node_modules/react-style-singleton/dist/es2015/component.js
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet = function(_a) {
    var styles = _a.styles, dynamic = _a.dynamic;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet;
};

// node_modules/react-remove-scroll-bar/dist/es2015/utils.js
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse = function(x) {
  return parseInt(x || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse(left), parse(top), parse(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};

// node_modules/react-remove-scroll-bar/dist/es2015/component.js
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles = function(_a, allowRelative, gapMode, important) {
  var left = _a.left, top = _a.top, right = _a.right, gap = _a.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var getCurrentUseCounter = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter) ? counter : 0;
};
var useLockAttribute = function() {
  React21.useEffect(function() {
    document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute);
      } else {
        document.body.setAttribute(lockAttribute, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar = function(_a) {
  var noRelative = _a.noRelative, noImportant = _a.noImportant, _b = _a.gapMode, gapMode = _b === void 0 ? "margin" : _b;
  useLockAttribute();
  var gap = React21.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React21.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};

// node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var options;
var nonPassive = passiveSupported ? { passive: false } : false;

// node_modules/react-remove-scroll/dist/es2015/handleScroll.js
var alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node, overflow) {
  var styles = window.getComputedStyle(node);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowY");
};
var elementCouldBeHScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowX");
};
var locationCouldBeScrolled = function(axis, node) {
  var ownerDocument = node.ownerDocument;
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a = getScrollVariables(axis, current), s = _a[1], d = _a[2];
      if (s > d) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument.body);
  return false;
};
var getVScrollVariables = function(_a) {
  var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a) {
  var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    if (target instanceof ShadowRoot) {
      target = target.host;
    } else {
      target = target.parentNode;
    }
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (noOverscroll && Math.abs(availableScroll) < 1 || !noOverscroll && delta > availableScroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (noOverscroll && Math.abs(availableScrollTop) < 1 || !noOverscroll && -delta > availableScrollTop)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};

// node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x, y) {
  return x[0] === y[0] && x[1] === y[1];
};
var generateStyle = function(id) {
  return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = React23.useRef([]);
  var touchStartRef = React23.useRef([0, 0]);
  var activeAxis = React23.useRef();
  var id = React23.useState(idCounter++)[0];
  var Style2 = React23.useState(styleSingleton)[0];
  var lastProps = React23.useRef(props);
  React23.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  React23.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React23.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = React23.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e) {
      return e.name === event.type && (e.target === event.target || event.target === e.shadowParent) && deltaCompare(e.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = React23.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e) {
        return e !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React23.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = React23.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = React23.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React23.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return React23.createElement(
    React23.Fragment,
    null,
    inert ? React23.createElement(Style2, { styles: generateStyle(id) }) : null,
    removeScrollBar ? React23.createElement(RemoveScrollBar, { gapMode: props.gapMode }) : null
  );
}
function getOutermostShadowParent(node) {
  var shadowParent = null;
  while (node !== null) {
    if (node instanceof ShadowRoot) {
      shadowParent = node.host;
      node = node.host;
    }
    node = node.parentNode;
  }
  return shadowParent;
}

// node_modules/react-remove-scroll/dist/es2015/sidecar.js
var sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar);

// node_modules/react-remove-scroll/dist/es2015/Combination.js
var ReactRemoveScroll = React24.forwardRef(function(props, ref) {
  return React24.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: sidecar_default }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var Combination_default = ReactRemoveScroll;

// node_modules/aria-hidden/dist/es2015/index.js
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x) {
    return Boolean(x);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          var attr = node.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e) {
          console.error("aria-hidden: cannot operate on ", node, e);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = parentNode || getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live], script")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};

// node_modules/@radix-ui/react-dialog/dist/index.mjs
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var DIALOG_NAME = "Dialog";
var [createDialogContext, createDialogScope] = createContextScope(DIALOG_NAME);
var [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME);
var Dialog = (props) => {
  const {
    __scopeDialog,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const triggerRef = React25.useRef(null);
  const contentRef = React25.useRef(null);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return (0, import_jsx_runtime7.jsx)(
    DialogProvider,
    {
      scope: __scopeDialog,
      triggerRef,
      contentRef,
      contentId: useId(),
      titleId: useId(),
      descriptionId: useId(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: React25.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children
    }
  );
};
Dialog.displayName = DIALOG_NAME;
var TRIGGER_NAME = "DialogTrigger";
var DialogTrigger = React25.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...triggerProps } = props;
    const context = useDialogContext(TRIGGER_NAME, __scopeDialog);
    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    return (0, import_jsx_runtime7.jsx)(
      Primitive.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState(context.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
  }
);
DialogTrigger.displayName = TRIGGER_NAME;
var PORTAL_NAME2 = "DialogPortal";
var [PortalProvider, usePortalContext] = createDialogContext(PORTAL_NAME2, {
  forceMount: void 0
});
var DialogPortal = (props) => {
  const { __scopeDialog, forceMount, children, container } = props;
  const context = useDialogContext(PORTAL_NAME2, __scopeDialog);
  return (0, import_jsx_runtime7.jsx)(PortalProvider, { scope: __scopeDialog, forceMount, children: React25.Children.map(children, (child) => (0, import_jsx_runtime7.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime7.jsx)(Portal, { asChild: true, container, children: child }) })) });
};
DialogPortal.displayName = PORTAL_NAME2;
var OVERLAY_NAME = "DialogOverlay";
var DialogOverlay = React25.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext(OVERLAY_NAME, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, props.__scopeDialog);
    return context.modal ? (0, import_jsx_runtime7.jsx)(Presence, { present: forceMount || context.open, children: (0, import_jsx_runtime7.jsx)(DialogOverlayImpl, { ...overlayProps, ref: forwardedRef }) }) : null;
  }
);
DialogOverlay.displayName = OVERLAY_NAME;
var DialogOverlayImpl = React25.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, __scopeDialog);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      (0, import_jsx_runtime7.jsx)(Combination_default, { as: Slot, allowPinchZoom: true, shards: [context.contentRef], children: (0, import_jsx_runtime7.jsx)(
        Primitive.div,
        {
          "data-state": getState(context.open),
          ...overlayProps,
          ref: forwardedRef,
          style: { pointerEvents: "auto", ...overlayProps.style }
        }
      ) })
    );
  }
);
var CONTENT_NAME = "DialogContent";
var DialogContent = React25.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext(CONTENT_NAME, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);
    return (0, import_jsx_runtime7.jsx)(Presence, { present: forceMount || context.open, children: context.modal ? (0, import_jsx_runtime7.jsx)(DialogContentModal, { ...contentProps, ref: forwardedRef }) : (0, import_jsx_runtime7.jsx)(DialogContentNonModal, { ...contentProps, ref: forwardedRef }) });
  }
);
DialogContent.displayName = CONTENT_NAME;
var DialogContentModal = React25.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);
    const contentRef = React25.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, context.contentRef, contentRef);
    React25.useEffect(() => {
      const content = contentRef.current;
      if (content) return hideOthers(content);
    }, []);
    return (0, import_jsx_runtime7.jsx)(
      DialogContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          var _a;
          event.preventDefault();
          (_a = context.triggerRef.current) == null ? void 0 : _a.focus();
        }),
        onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (isRightClick) event.preventDefault();
        }),
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault()
        )
      }
    );
  }
);
var DialogContentNonModal = React25.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);
    const hasInteractedOutsideRef = React25.useRef(false);
    const hasPointerDownOutsideRef = React25.useRef(false);
    return (0, import_jsx_runtime7.jsx)(
      DialogContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          var _a, _b;
          (_a = props.onCloseAutoFocus) == null ? void 0 : _a.call(props, event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current) (_b = context.triggerRef.current) == null ? void 0 : _b.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          var _a, _b;
          (_a = props.onInteractOutside) == null ? void 0 : _a.call(props, event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = (_b = context.triggerRef.current) == null ? void 0 : _b.contains(target);
          if (targetIsTrigger) event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      }
    );
  }
);
var DialogContentImpl = React25.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME, __scopeDialog);
    const contentRef = React25.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    useFocusGuards();
    return (0, import_jsx_runtime7.jsxs)(import_jsx_runtime7.Fragment, { children: [
      (0, import_jsx_runtime7.jsx)(
        FocusScope,
        {
          asChild: true,
          loop: true,
          trapped: trapFocus,
          onMountAutoFocus: onOpenAutoFocus,
          onUnmountAutoFocus: onCloseAutoFocus,
          children: (0, import_jsx_runtime7.jsx)(
            DismissableLayer,
            {
              role: "dialog",
              id: context.contentId,
              "aria-describedby": context.descriptionId,
              "aria-labelledby": context.titleId,
              "data-state": getState(context.open),
              ...contentProps,
              ref: composedRefs,
              onDismiss: () => context.onOpenChange(false)
            }
          )
        }
      ),
      (0, import_jsx_runtime7.jsxs)(import_jsx_runtime7.Fragment, { children: [
        (0, import_jsx_runtime7.jsx)(TitleWarning, { titleId: context.titleId }),
        (0, import_jsx_runtime7.jsx)(DescriptionWarning, { contentRef, descriptionId: context.descriptionId })
      ] })
    ] });
  }
);
var TITLE_NAME = "DialogTitle";
var DialogTitle = React25.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...titleProps } = props;
    const context = useDialogContext(TITLE_NAME, __scopeDialog);
    return (0, import_jsx_runtime7.jsx)(Primitive.h2, { id: context.titleId, ...titleProps, ref: forwardedRef });
  }
);
DialogTitle.displayName = TITLE_NAME;
var DESCRIPTION_NAME = "DialogDescription";
var DialogDescription = React25.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...descriptionProps } = props;
    const context = useDialogContext(DESCRIPTION_NAME, __scopeDialog);
    return (0, import_jsx_runtime7.jsx)(Primitive.p, { id: context.descriptionId, ...descriptionProps, ref: forwardedRef });
  }
);
DialogDescription.displayName = DESCRIPTION_NAME;
var CLOSE_NAME = "DialogClose";
var DialogClose = React25.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...closeProps } = props;
    const context = useDialogContext(CLOSE_NAME, __scopeDialog);
    return (0, import_jsx_runtime7.jsx)(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
      }
    );
  }
);
DialogClose.displayName = CLOSE_NAME;
function getState(open) {
  return open ? "open" : "closed";
}
var TITLE_WARNING_NAME = "DialogTitleWarning";
var [WarningProvider, useWarningContext] = createContext2(TITLE_WARNING_NAME, {
  contentName: CONTENT_NAME,
  titleName: TITLE_NAME,
  docsSlug: "dialog"
});
var TitleWarning = ({ titleId }) => {
  const titleWarningContext = useWarningContext(TITLE_WARNING_NAME);
  const MESSAGE = `\`${titleWarningContext.contentName}\` requires a \`${titleWarningContext.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleWarningContext.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;
  React25.useEffect(() => {
    if (titleId) {
      const hasTitle = document.getElementById(titleId);
      if (!hasTitle) console.error(MESSAGE);
    }
  }, [MESSAGE, titleId]);
  return null;
};
var DESCRIPTION_WARNING_NAME = "DialogDescriptionWarning";
var DescriptionWarning = ({ contentRef, descriptionId }) => {
  const descriptionWarningContext = useWarningContext(DESCRIPTION_WARNING_NAME);
  const MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${descriptionWarningContext.contentName}}.`;
  React25.useEffect(() => {
    var _a;
    const describedById = (_a = contentRef.current) == null ? void 0 : _a.getAttribute("aria-describedby");
    if (descriptionId && describedById) {
      const hasDescription = document.getElementById(descriptionId);
      if (!hasDescription) console.warn(MESSAGE);
    }
  }, [MESSAGE, contentRef, descriptionId]);
  return null;
};
var Root = Dialog;
var Portal2 = DialogPortal;
var Overlay = DialogOverlay;
var Content = DialogContent;
var Title = DialogTitle;
var Close = DialogClose;

// node_modules/@fuels/react/dist/index.mjs
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
function vr(e) {
  return { get(r, o) {
    return o === e ? Reflect.get(r, "data") : Reflect.get(r, o);
  } };
}
function m(e, t, r) {
  let o = useQuery(t, r);
  return (0, import_react4.useMemo)(() => new Proxy(o, vr(e)), [e, o]);
}
var Ze = () => {
  let { fuel: e } = u(), { mutate: t, mutateAsync: r, ...o } = useMutation({ mutationFn: async (a) => (a && await e.selectConnector(a), e.connect()) });
  return { connect: t, connectAsync: r, ...o };
};
var n = { base: ["fuel"], account: () => n.base.concat("account"), accounts: () => n.base.concat("accounts"), assets: () => n.base.concat("assets"), contract: (e, t, r) => {
  let o = n.base.concat("contract").concat(e);
  return typeof r < "u" && o.push(r), typeof t < "u" && o.push(t), o;
}, chain: () => n.base.concat("chain"), chainId: () => n.base.concat("chain-id"), isConnected: () => n.base.concat("isConnected"), networks: () => n.base.concat("networks"), provider: () => n.base.concat("provider"), balance: (e, t, r) => {
  let o = n.base.concat("balance");
  return e && o.push(e), t && o.push(t), r !== void 0 && o.push(r), o;
}, wallet: (e, t) => {
  let r = n.base.concat("wallet");
  return e && r.push(e), t && r.push(t), r;
}, transaction: (e) => {
  let t = n.base.concat("transaction");
  return e && t.push(e), t;
}, transactionReceipts: (e, t) => {
  let r = n.transaction(e).concat("receipts");
  return t !== void 0 && r.push(t), r;
}, transactionResult: (e, t) => {
  let r = n.transaction(e).concat("result");
  return t !== void 0 && r.push(t), r;
}, nodeInfo: (e) => {
  let t = n.base.concat("nodeInfo");
  return e && t.push(e), t;
}, connectorList: () => n.base.concat("connectorList"), currentConnector: () => n.base.concat(["currentConnector"]), currentNetwork: () => n.base.concat("currentNetwork"), isSupportedNetwork: (e, t, r, o) => {
  let a = n.base.concat("isSupportedNetwork");
  return e && a.push(e), t && a.push(t), r && a.push(r), o && a.push(o), a;
} };
var oe = { connect: "connect", addAssets: "addAssets", addNetwork: "addNetwork" };
var I = ["Bako Safe", "Burner Wallet", "Fuel Wallet", "Fuel Wallet Development", "Fuelet Wallet"];
var De = { chainId: CHAIN_IDS.fuel.mainnet, url: "https://mainnet.fuel.network/v1/graphql", bridgeURL: "https://app.fuel.network/bridge?from=eth&to=fuel&auto_close=true" };
var $e = [{ chainId: CHAIN_IDS.fuel.testnet, url: "https://testnet.fuel.network/v1/graphql", bridgeURL: "https://app-testnet.fuel.network/bridge?from=eth&to=fuel&auto_close=true" }, { chainId: CHAIN_IDS.fuel.devnet, url: "https://devnet.fuel.network/v1/graphql", bridgeURL: "https://app-devnet.fuel.network/bridge?from=eth&to=fuel&auto_close=true" }, De];
function ne(e) {
  return I.includes(e == null ? void 0 : e.name);
}
var Je = ({ query: e } = {}) => {
  let { fuel: t } = u();
  return m("connectors", { queryKey: n.connectorList(), queryFn: async () => t.connectors(), placeholderData: [], ...e });
};
var et = (0, import_react4.createContext)(null);
var b = () => {
  let e = (0, import_react4.useContext)(et);
  if (!e) throw new Error("useConnectUI must be used within a FuelUIProvider");
  return e;
};
var Pr = (e) => e.sort((t, r) => {
  if (t.connected !== r.connected) return t.connected ? -1 : 1;
  let o = I.includes(t.name) && t.installed, a = I.includes(r.name) && r.installed;
  return o !== a ? o ? -1 : 1 : t.name.localeCompare(r.name);
});
function tt({ fuelConfig: e, children: t, theme: r, uiConfig: o }) {
  let { isPending: a, isError: c, connectAsync: p } = Ze(), { connectors: l, isLoading: d } = Je({ query: { select: Pr } }), { isConnected: f } = Q(), [y, T] = (0, import_react4.useState)(null), [h, x] = (0, import_react4.useState)("LIST"), [v, X] = (0, import_react4.useState)(false), [q, w] = (0, import_react4.useState)(null);
  (0, import_react4.useEffect)(() => {
    if (!y) return;
    let g = l.find((ke) => ke.name === y.name);
    g && y.installed !== (g == null ? void 0 : g.installed) && T(g);
  }, [l, y]);
  let K = (0, import_react4.useCallback)(() => {
    w(null), T(null), x("LIST");
  }, []), te = (0, import_react4.useCallback)(async (g) => {
    try {
      w(null), await p(g.name);
    } catch (ke) {
      w(ke);
    }
  }, [p]), re = (0, import_react4.useCallback)(async (g) => {
    x("CONNECTING"), await te(g);
  }, [te]), _e = (0, import_react4.useCallback)(async (g) => {
    T(g), g.installed ? ne(g) ? re(g) : x("PREDICATE_EXTERNAL_DISCLAIMER") : x("INSTALL");
  }, [re]), Ye = (0, import_react4.useMemo)(() => {
    let g = (e.connectors || []).length > l.length;
    return d || g;
  }, [l, d, e]), Ve = (0, import_react4.useCallback)(() => {
    T(null), w(null), x("LIST"), X(true);
  }, []), Ge = (0, import_react4.useCallback)(() => {
    w(null), X(false);
  }, []);
  (0, import_react4.useEffect)(() => {
    let g = document.createElement("style");
    return g.appendChild(document.createTextNode(`@import url("https://fonts.googleapis.com/css2?family=Inter:opsz,wght@14..32,100..900&display=swap"); .fuel-connectors * { box-sizing: border-box; } .fuel-connectors .fuel-connectors-dialog-content:focus { outline: none; } @media (max-width: 430px) { .fuel-connectors .fuel-connectors-dialog-content { top: 50%; width: 100%; border-radius: 36px; } } .fuel-connectors .fuel-connectors-connector-item { transition: background-color 50ms cubic-bezier(0.16, 1, 0.3, 1); background-color: var(--fuel-connector-background); } .fuel-connectors .fuel-connectors-connector-item:active { opacity: 0.8; } .fuel-connectors .fuel-connectors-connector-item:hover { background-color: var(--fuel-connector-hover); } .fuel-connectors .fuel-connectors-connector-button { transition: background-color 50ms cubic-bezier(0.16, 1, 0.3, 1); background-color: var(--fuel-button-background); color: var(--fuel-color-bold); } .fuel-connectors .fuel-connectors-connector-button:visited { color: var(--fuel-color-bold); } .fuel-connectors .fuel-connectors-connector-button:hover { background-color: var(--fuel-button-background-hover); } .fuel-connectors .fuel-connectors-connector-button-primary { transition: background-color 50ms cubic-bezier(0.16, 1, 0.3, 1); background-color: var(--fuel-green-11); color: var(--fuel-black-color); } .fuel-connectors .fuel-connectors-connector-button-primary:visited { color: var(--fuel-black-color); } .fuel-connectors .fuel-connectors-connector-button-primary:hover { background-color: var(--fuel-green-11); } .fuel-connectors .fuel-connectors-back-icon { transition: background-color 50ms cubic-bezier(0.16, 1, 0.3, 1); } .fuel-connectors .fuel-connectors-back-icon[data-connector='false'] { visibility: hidden; } .fuel-connectors .fuel-connectors-back-icon:hover, .fuel-connectors .fuel-connectors-back-icon:active { opacity: 1; background-color: var(--fuel-connector-hover); } .fuel-connectors .fuel-connectors-close-icon { transition: background-color 50ms cubic-bezier(0.16, 1, 0.3, 1); } .fuel-connectors .fuel-connectors-close-icon:hover, .fuel-connectors .fuel-connectors-close-icon:active { opacity: 1; background-color: var(--fuel-connector-hover); } .fuel-connectors .fuel-connectors-button-base { cursor: pointer; } .fuel-connectors .fuel-connectors-button:disabled { cursor: not-allowed; } .fuel-connectors .fuel-connectors-button { transition: background-color 50ms cubic-bezier(0.16, 1, 0.3, 1); background-color: var(--fuel-green-11); } .fuel-connectors .fuel-connectors-button:disabled { background-color: var(--fuel-border-color); } .fuel-connectors .fuel-connectors-button-disconnect { transition: background-color 50ms cubic-bezier(0.16, 1, 0.3, 1); background-color: var(--fuel-button-background); } .fuel-connectors .fuel-connectors-button-disconnect:hover { background-color: var(--fuel-button-background-hover); } .fuel-connectors .fuel-connectors-link-underline:hover { text-decoration: underline; } @keyframes fuelOverlayShow { from { opacity: 0; } to { opacity: 1; } } @keyframes fuelSpin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } } @keyframes fuelContentShow { from { opacity: 0; transform: translate(-50%, -48%) scale(0.96); } to { opacity: 1; transform: translate(-50%, -50%) scale(1); } } @keyframes fuelLoader { 0% { background-position: -468px 0 } 100% { background-position: 468px 0 } }`)), document.head.appendChild(g), () => {
      document.head.removeChild(g);
    };
  }, []);
  let gr = (0, import_react4.useMemo)(() => ({ theme: r || "light", fuelConfig: e, uiConfig: o, error: q, setError: w, isConnected: !!f, isConnecting: a, isLoading: Ye, isError: c, connectors: l, connect: Ve, cancel: Ge, dialog: { route: h, setRoute: x, connector: y, isOpen: v, connect: _e, retryConnect: te, back: K, _startConnection: re } }), [r, e, o, q, f, a, Ye, c, l, y, h, v, Ge, re, _e, Ve, te, K]);
  return (0, import_jsx_runtime8.jsx)(et.Provider, { value: gr, children: t });
}
var rt = (e, t) => {
  let { image: r } = e;
  return typeof r == "object" ? t === "dark" ? r.dark : r.light : r;
};
function H({ connectorName: e, connectorMetadata: t, ...r }) {
  return t.image ? (0, import_jsx_runtime8.jsx)("img", { height: `${r.size}px`, width: `${r.size}px`, src: rt(t, r.theme), alt: `${e} icon` }) : null;
}
var Re = { textAlign: "center", fontSize: "1.2em", fontWeight: 500, color: "var(--fuel-color-bold)", margin: "0 0 0.4em 0", padding: "0 1.8em" };
var z = ({ children: e }) => (0, import_jsx_runtime8.jsx)("h2", { style: Re, children: e });
var ie = { color: "var(--fuel-gray-12)", fontSize: "0.9em", fontWeight: 400, textAlign: "center", margin: "0 1.2em", lineHeight: "1.2em", padding: "0 2em", opacity: 0.8 };
var L = ({ children: e }) => (0, import_jsx_runtime8.jsx)("p", { style: ie, children: e });
var kr = { color: "var(--fuel-gray-12)", fontSize: "0.8em", fontWeight: 400, textAlign: "center", margin: "2em auto 0", lineHeight: "1.2em", padding: "0 2em", opacity: 0.5 };
var ot = ({ children: e }) => (0, import_jsx_runtime8.jsx)("p", { style: kr, children: e });
var Nr = { ...ie, color: "var(--fuel-color-error)" };
var nt = ({ children: e }) => (0, import_jsx_runtime8.jsx)("p", { style: Nr, children: e });
var Dr = { display: "flex", justifyContent: "center", height: "6.2em", width: "100%", marginTop: "1.6em", marginBottom: "1.2em" };
var _ = ({ children: e }) => (0, import_jsx_runtime8.jsx)("div", { style: Dr, children: e });
var at = { display: "flex", boxSizing: "border-box", textDecoration: "none", cursor: "pointer", justifyContent: "center", alignItems: "center", margin: "0.4rem 1rem 0", padding: "0.6rem 0", fontSize: "0.875em", borderRadius: "var(--fuel-border-radius)" };
var Y = ({ href: e, children: t, style: r, ...o }) => (0, import_jsx_runtime8.jsx)("a", { href: e, style: at, ...o, className: "fuel-connectors-connector-button", children: t });
var Ie = { display: "flex", flexDirection: "column", gap: "8px", marginBottom: "24px" };
var A = ({ children: e }) => (0, import_jsx_runtime8.jsx)("div", { style: Ie, children: e });
var F = ({ href: e, children: t, ...r }) => (0, import_jsx_runtime8.jsx)("a", { href: e, style: at, ...r, className: "fuel-connectors-connector-button-primary", children: t });
function st() {
  let { theme: e, dialog: { connector: t, setRoute: r } } = b();
  if (!t) return null;
  let { install: { action: o, link: a, description: c } } = t.metadata;
  (0, import_react4.useEffect)(() => {
    (async () => {
      await t.ping() && r("CONNECTING");
    })();
  }, [t, r]);
  let p = o || "Install";
  return (0, import_jsx_runtime8.jsxs)("div", { children: [(0, import_jsx_runtime8.jsx)(_, { children: (0, import_jsx_runtime8.jsx)(H, { connectorMetadata: t.metadata, connectorName: t.name, size: 100, theme: e }) }), (0, import_jsx_runtime8.jsxs)(A, { children: [(0, import_jsx_runtime8.jsx)(z, { children: t.name }), (0, import_jsx_runtime8.jsx)(L, { children: c })] }), (0, import_jsx_runtime8.jsx)(F, { href: a, target: "_blank", children: p }), (0, import_jsx_runtime8.jsxs)(ot, { children: ["If you have installed it and it is not detected,", (0, import_jsx_runtime8.jsx)("br", {}), "try refreshing the page."] })] });
}
var Ir = { display: "flex", alignItems: "center", boxSizing: "border-box", cursor: "pointer", width: "100%", gap: "var(--fuel-items-gap)", padding: "0.8em", borderRadius: "16px", fontWeight: 400 };
var se = ({ children: e, ...t }) => (0, import_jsx_runtime8.jsx)("div", { style: Ir, ...t, className: "fuel-connectors-connector-item", children: e });
var Fr = { display: "flex", flexDirection: "column", alignItems: "center", gap: "var(--fuel-items-gap)", padding: "0px 14px" };
var Ee = ({ children: e }) => (0, import_jsx_runtime8.jsx)("div", { style: Fr, children: e });
var Er = { fontSize: "0.875em" };
var ce = ({ children: e }) => (0, import_jsx_runtime8.jsx)("div", { style: Er, children: e });
var ct = { borderRadius: "var(--fuel-border-radius)", fontSize: "var(--fuel-font-size-xs)", padding: "2px 8px", textTransform: "uppercase", marginLeft: "auto" };
var lt = ({ children: e }) => {
  let t = { ...ct, backgroundColor: "var(--fuel-blue-3)", color: "var(--fuel-blue-11)" };
  return (0, import_jsx_runtime8.jsx)("div", { style: t, children: e });
};
var ut = ({ children: e }) => {
  let t = { ...ct, backgroundColor: "var(--fuel-green-3)", color: "var(--fuel-green-11)" };
  return (0, import_jsx_runtime8.jsx)("div", { style: t, children: e });
};
var pt = { width: "100%", color: "#797979", fontSize: "var(--fuel-font-size-xs)", fontStyle: "normal", fontWeight: 400, margin: 0 };
var dt = ({ children: e }) => (0, import_jsx_runtime8.jsx)("p", { style: pt, children: e });
var mt = ({ children: e }) => {
  let t = { ...pt, marginTop: "14px" };
  return (0, import_jsx_runtime8.jsx)("p", { style: t, children: e });
};
function Ar() {
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Mobile|mobile|CriOS/i.test(navigator.userAgent);
}
function Ur() {
  return /FueletMobileApp/i.test(navigator.userAgent);
}
function qr(e) {
  return e === "Fuelet Wallet" && Ar() && !Ur();
}
function yt({ name: e, connected: t, installed: r }) {
  let o = (0, import_react4.useMemo)(() => !I.includes(e), [e]);
  return t ? (0, import_jsx_runtime8.jsx)(ut, { children: "Connected" }) : !o && r && !qr(e) ? (0, import_jsx_runtime8.jsx)(lt, { children: "Installed" }) : null;
}
var Lr = ({ connect: e, theme: t, connector: r, index: o }) => (0, import_jsx_runtime8.jsxs)(se, { tabIndex: o + 1, "aria-label": `Connect to ${r.name}`, "data-installed": r.installed, "data-connected": r.connected, onClick: (a) => {
  a.preventDefault(), e(r);
}, children: [(0, import_jsx_runtime8.jsx)(H, { connectorMetadata: r.metadata, connectorName: r.name, size: 32, theme: t }), (0, import_jsx_runtime8.jsx)(ce, { children: r.name }), (0, import_jsx_runtime8.jsx)(yt, { name: r.name, connected: r.connected, installed: r.installed })] }, r.name);
var Ae = (0, import_react4.memo)(Lr);
function Ct({ size: e, ...t }) {
  return (0, import_jsx_runtime8.jsxs)("svg", { fill: "none", xmlns: "http://www.w3.org/2000/svg", width: e, height: e, viewBox: "0 0 16 16", ...t, children: [(0, import_jsx_runtime8.jsx)("title", { children: "Back Icon" }), (0, import_jsx_runtime8.jsx)("path", { fill: "currentColor", fillRule: "evenodd", d: "M11.04 1.46a1 1 0 0 1 0 1.41L5.91 8l5.13 5.13a1 1 0 1 1-1.41 1.41L3.79 8.71a1 1 0 0 1 0-1.42l5.84-5.83a1 1 0 0 1 1.41 0Z", clipRule: "evenodd" })] });
}
function vt({ size: e, ...t }) {
  return (0, import_jsx_runtime8.jsxs)("svg", { fill: "none", xmlns: "http://www.w3.org/2000/svg", width: e, height: e, viewBox: "0 0 16 16", ...t, children: [(0, import_jsx_runtime8.jsx)("title", { children: "Close Icon" }), (0, import_jsx_runtime8.jsx)("path", { fill: "currentColor", fillRule: "evenodd", d: "M2.54 2.54a1 1 0 0 1 1.42 0L8 6.6l4.04-4.05a1 1 0 1 1 1.42 1.42L9.4 8l4.05 4.04a1 1 0 0 1-1.42 1.42L8 9.4l-4.04 4.05a1 1 0 0 1-1.42-1.42L6.6 8 2.54 3.96a1 1 0 0 1 0-1.42Z", clipRule: "evenodd" })] });
}
var Wr = { display: "flex", alignItems: "center", justifyContent: "space-between", paddingLeft: "16px", paddingRight: "16px" };
var le = ({ children: e, ...t }) => (0, import_jsx_runtime8.jsx)("div", { style: Wr, ...t, children: e });
var Hr = { padding: "8px 14px 12px", margin: 0, textAlign: "center", fontSize: "var(--fuel-font-size)", fontWeight: 500 };
var ue = ({ children: e, ...t }) => (0, import_jsx_runtime8.jsx)(Title, { style: Hr, ...t, children: e });
var zr = { height: "1px", width: "100%", backgroundColor: "var(--fuel-border-color)", margin: "10px 0", padding: 0 };
var pe = (e) => (0, import_jsx_runtime8.jsx)("div", { style: zr, ...e });
var _r = { position: "relative", overflowY: "auto" };
var de = (e) => (0, import_jsx_runtime8.jsx)("div", { style: _r, ...e });
var Yr = { fill: "var(--fuel-color)", padding: "7px", borderRadius: "12px", display: "flex", alignItems: "center", justifyContent: "center", cursor: "pointer" };
var me = ({ size: e, ...t }) => (0, import_jsx_runtime8.jsx)(Ct, { size: e, style: Yr, ...t, className: "fuel-connectors-back-icon" });
var Vr = { fill: "var(--fuel-color)", padding: "7px", borderRadius: "12px", display: "flex", alignItems: "center", justifyContent: "center", cursor: "pointer" };
var fe = ({ size: e, ...t }) => (0, import_jsx_runtime8.jsx)(vt, { size: e, style: Vr, ...t, className: "fuel-connectors-close-icon" });
var Gr = { animationDuration: "1s", animationFillMode: "forwards", animationIterationCount: "infinite", animationName: "fuelLoader", animationTimingFunction: "linear", backgroundColor: "#d1d5d9", background: "var(--fuel-loader-background)", backgroundSize: "1000px 104px", height: "fit-content", position: "relative", overflow: "hidden", color: "transparent", pointerEvents: "none" };
var Ue = ({ children: e, ...t }) => (0, import_jsx_runtime8.jsx)("div", { style: Gr, ...t, children: e });
function xt({ items: e }) {
  return Array.from({ length: e }).map((r, o) => (0, import_jsx_runtime8.jsxs)(se, { children: [(0, import_jsx_runtime8.jsx)(Ue, { children: (0, import_jsx_runtime8.jsx)("div", { style: { height: 32, width: 32 } }) }), (0, import_jsx_runtime8.jsx)(Ue, { children: (0, import_jsx_runtime8.jsx)(ce, { children: "Fuel Wallet" }) })] }, o));
}
var $r = ["Fuelet Wallet", "Burner Wallet", "Ethereum Wallets", "Solana Wallets"];
function Pt() {
  var _a;
  let { fuelConfig: e, connectors: t, isLoading: r, theme: o, dialog: { connect: a } } = b(), c = (0, import_react4.useMemo)(() => /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Mobile|mobile|CriOS/i.test(navigator.userAgent), []), { native: p, external: l } = (0, import_react4.useMemo)(() => {
    let f = c ? t.filter((h) => $r.some((x) => x === h.name)) : t, y = f.filter((h) => !I.includes(h.name));
    return { native: f.filter((h) => I.includes(h.name)), external: y };
  }, [t, c]), d = !!p.length && !!l.length;
  return r ? (0, import_jsx_runtime8.jsx)(Ee, { children: (0, import_jsx_runtime8.jsx)(xt, { items: ((_a = e.connectors) == null ? void 0 : _a.length) || 2 }) }) : (0, import_jsx_runtime8.jsxs)(Ee, { children: [d && (0, import_jsx_runtime8.jsx)(dt, { children: "Fuel Native Wallets" }), p.map((f, y) => (0, import_jsx_runtime8.jsx)(Ae, { connect: a, theme: o, connector: f, index: y }, f.name)), d && (0, import_jsx_runtime8.jsx)(mt, { children: "Non-Native Wallets" }), l.map((f, y) => (0, import_jsx_runtime8.jsx)(Ae, { connect: a, theme: o, connector: f, index: y }, f.name))] });
}
var ge = ({ size: e, color: t }) => {
  let r = { height: `${e}px`, width: `${e}px`, border: "4px solid rgba(0, 0, 0, 0.1)", borderTopColor: t, borderRadius: "50%", animation: "fuelSpin 1s infinite linear" };
  return (0, import_jsx_runtime8.jsx)("div", { style: r });
};
function Tt() {
  let { fuel: e } = u(), t = useQueryClient();
  function r() {
    t.invalidateQueries({ queryKey: n.account() }), t.invalidateQueries({ queryKey: n.isConnected() }), t.invalidateQueries({ queryKey: n.wallet() }), t.invalidateQueries({ queryKey: n.balance() }), t.invalidateQueries({ queryKey: n.provider() }), t.invalidateQueries({ queryKey: n.nodeInfo() }), t.invalidateQueries({ queryKey: n.accounts() }), t.invalidateQueries({ queryKey: n.currentConnector() });
  }
  async function o() {
    t.resetQueries({ queryKey: n.connectorList(), exact: true }), t.invalidateQueries({ queryKey: n.currentConnector() });
  }
  function a() {
    t.invalidateQueries({ queryKey: n.account() }), t.invalidateQueries({ queryKey: n.wallet() }), t.invalidateQueries({ queryKey: n.balance() });
  }
  function c() {
    t.invalidateQueries({ queryKey: n.currentConnector() }), t.invalidateQueries({ queryKey: n.isConnected() }), t.invalidateQueries({ queryKey: n.account() }), t.invalidateQueries({ queryKey: n.wallet() }), t.invalidateQueries({ queryKey: n.balance() }), t.invalidateQueries({ queryKey: n.provider() }), t.invalidateQueries({ queryKey: n.nodeInfo() }), t.invalidateQueries({ queryKey: n.accounts() }), t.resetQueries({ queryKey: n.connectorList(), exact: true });
  }
  function p() {
    t.invalidateQueries({ queryKey: n.currentNetwork() }), t.invalidateQueries({ queryKey: n.networks() }), t.invalidateQueries({ queryKey: n.provider() }), t.invalidateQueries({ queryKey: n.transactionReceipts() }), t.invalidateQueries({ queryKey: n.chain() }), t.invalidateQueries({ queryKey: n.nodeInfo() });
  }
  function l() {
    t.invalidateQueries({ queryKey: n.account() }), t.invalidateQueries({ queryKey: n.accounts() });
  }
  function d() {
    t.invalidateQueries({ queryKey: n.assets() });
  }
  return (0, import_react4.useEffect)(() => (e.on(e.events.currentAccount, a), e.on(e.events.currentConnector, r), e.on(e.events.connectors, o), e.on(e.events.connection, c), e.on(e.events.accounts, l), e.on(e.events.currentNetwork, p), e.on(e.events.assets, d), () => {
    e.off(e.events.currentConnector, r), e.off(e.events.currentAccount, a), e.off(e.events.connectors, o), e.off(e.events.connection, c), e.off(e.events.accounts, l), e.off(e.events.currentNetwork, p), e.off(e.events.assets, d);
  }), [e, t]), null;
}
var wt = (0, import_react4.createContext)(null);
var u = () => {
  let e = (0, import_react4.useContext)(wt);
  if (!e) throw new Error("useFuel must be used within a FuelHooksProvider");
  return e;
};
var qe = ({ children: e, fuelConfig: t, networks: r }) => {
  let o = (0, import_react4.useRef)(new Fuel(t));
  return (0, import_jsx_runtime8.jsxs)(wt.Provider, { value: { fuel: o.current, networks: r }, children: [(0, import_jsx_runtime8.jsx)(Tt, {}), e] });
};
var Ke = "@fuels/predicate-address-disclaimer";
function Nt() {
  let { cancel: e } = b();
  return (0, import_jsx_runtime8.jsxs)("div", { children: [(0, import_jsx_runtime8.jsx)(A, { children: (0, import_jsx_runtime8.jsxs)("div", { style: { color: "var(--fuel-blue-a11)", backgroundColor: "var(--fuel-blue-a3)", fontSize: "var(--fuel-font-size-xs)", margin: "0 1.2em", border: "1px solid var(--fuel-blue-6)", borderRadius: "var(--fuel-border-radius)", padding: 12 }, children: [(0, import_jsx_runtime8.jsx)("b", { children: "Please Note:" }), " EVM/SVM addresses will differ from your", " ", (0, import_jsx_runtime8.jsx)("b", { children: "Fuel predicate address" }), ". This is expected behavior.", (0, import_jsx_runtime8.jsx)("br", {}), (0, import_jsx_runtime8.jsx)("br", {}), "For more details,", " ", (0, import_jsx_runtime8.jsx)("a", { href: "https://github.com/FuelLabs/fuel-connectors/wiki", target: "_blank", rel: "noreferrer", className: "fuel-connectors-link-underline", style: { fontWeight: 600 }, children: "check our documentation" }), "."] }) }), (0, import_jsx_runtime8.jsx)(F, { onClick: () => {
    localStorage.setItem(Ke, Date.now().toString()), e();
  }, children: "Continue to application" })] });
}
function Rt({ className: e }) {
  let { fuel: t } = u(), { error: r, isConnecting: o, theme: a, cancel: c, dialog: { route: p, setRoute: l, connector: d, retryConnect: f }, isConnected: y } = b(), [T, h] = (0, import_react4.useState)("connect"), { description: x, operation: v, cta: X } = (0, import_react4.useMemo)(() => T === "connect" ? { description: `Click on the button below to connect to ${location.origin}.`, operation: "connection", cta: "Connect" } : { description: "Sign this message to prove you own this wallet and proceed. Canceling will disconnect you.", operation: "signature", cta: "Sign" }, [T]);
  return (0, import_react4.useEffect)(() => {
    if (y && p === "CONNECTING" && !o) {
      if (d && ne(d)) {
        c();
        return;
      }
      if (localStorage.getItem(Ke)) {
        c();
        return;
      }
      l("PREDICATE_ADDRESS_DISCLAIMER");
    }
  }, [y, d, p, l, o, c]), (0, import_react4.useEffect)(() => {
    let q = (w) => {
      w.metadata && "pendingSignature" in w.metadata && h(w.metadata.pendingSignature ? "sign" : "connect");
    };
    return t.on(t.events.currentConnector, q), () => {
      t.off(t.events.currentConnector, q);
    };
  }, [t]), d ? (0, import_jsx_runtime8.jsxs)("div", { className: e, children: [(0, import_jsx_runtime8.jsx)(_, { children: (0, import_jsx_runtime8.jsx)(H, { connectorMetadata: d.metadata, connectorName: d.name, size: 100, theme: a }) }), (0, import_jsx_runtime8.jsxs)(A, { children: [(0, import_jsx_runtime8.jsx)(z, { children: d.name }), o ? (0, import_jsx_runtime8.jsxs)(L, { children: ["Requesting ", v, " to ", (0, import_jsx_runtime8.jsx)("br", {}), " ", d.name, "."] }) : (0, import_jsx_runtime8.jsx)(L, { children: x }), r && (0, import_jsx_runtime8.jsx)(nt, { children: r.message })] }), o ? (0, import_jsx_runtime8.jsx)(Y, { children: (0, import_jsx_runtime8.jsx)(ge, { size: 26, color: "var(--fuel-loader-background)" }) }) : (0, import_jsx_runtime8.jsx)(F, { onClick: () => f(d), children: X })] }) : null;
}
var lo = { display: "flex", flexDirection: "column", overflow: "hidden", color: "var(--fuel-color)", userSelect: "none", maxHeight: "calc(100% - 20px)", backgroundColor: "var(--fuel-dialog-background)", position: "fixed", left: "50%", transform: "translate(-50%, -50%)", borderRadius: "36px", padding: "14px 0px", paddingBottom: "36px", animation: "fuelContentShow 150ms cubic-bezier(0.16, 1, 0.3, 1)", top: "50%", width: "360px", maxWidth: "calc(100% - 20px)", boxShadow: "hsl(206 22% 7% / 35%) 0px 10px 38px -10px, hsl(206 22% 7% / 20%) 0px 10px 20px -15px" };
var Z = (e) => (0, import_jsx_runtime8.jsx)(Content, { style: lo, ...e, className: "fuel-connectors-dialog-content", onPointerDownOutside: (t) => {
  var _a;
  ((_a = document.querySelector("w3m-modal")) == null ? void 0 : _a.classList.contains("open")) && t.preventDefault();
} });
var po = { "--fuel-font-family": '"Inter", "Segoe UI", "Roboto", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif', "--fuel-font-size": "16px", "--fuel-font-size-xs": "12px", "--fuel-letter-spacing": "-0.64px", "--fuel-border-radius": "6px", "--fuel-items-gap": "8px", "--fuel-border": "1px solid var(--fuel-border-color)", "--fuel-color-error": "#f25a68" };
var mo = { "--fuel-color": "#141414", "--fuel-color-bold": "#000000", "--fuel-dialog-background": "white", "--fuel-overlay-background": "rgba(71,88,107,0.24)", "--fuel-connector-background": "rgb(250 250 250)", "--fuel-connector-hover": "rgb(241 243 244)", "--fuel-border-color": "hsl(210deg 9.52% 83.53%)", "--fuel-border-hover": "hsla(0, 0%, 78.04%, 1)", "--fuel-button-background": "rgb(220 220 220)", "--fuel-button-background-hover": "rgb(203 205 207)", "--fuel-loader-background": "linear-gradient(to right, hsl(0, 0%, 92%) 8%, hsl(0, 0%, 85%) 18%, hsl(0, 0%, 92%) 33%)", "--fuel-green-3": "#D9FCE3", "--fuel-green-11": "#008347", "--fuel-blue-3": "#E6F4FE", "--fuel-blue-6": "#ACD8FC", "--fuel-blue-11": "#0D74CE", "--fuel-blue-a3": "color(display-p3 0.7686 0.898 1/0.334)", "--fuel-blue-a11": "color(display-p3 0 0.3059 0.7333/0.794)", "--fuel-gray-10": "#838383", "--fuel-gray-11": "#646464", "--fuel-gray-12": "#202020", "--fuel-separator-color": "rgb(83 79 79 / 13%)", "--fuel-black-color": "#FFFFFF" };
var fo = { "--fuel-color": "#e4e7e7", "--fuel-color-bold": "#ffffff", "--fuel-dialog-background": "rgb(25 26 26)", "--fuel-overlay-background": "rgba(20, 20, 20, 0.8)", "--fuel-connector-background": "rgba(255, 255, 255, 0.02)", "--fuel-connector-hover": "rgba(255, 255, 255, 0.05)", "--fuel-border-color": "rgba(255, 255, 255, 0.05)", "--fuel-border-hover": "hsla(0, 0%, 50%, 1)", "--fuel-button-background": "hsla(0, 0%, 30%, 1)", "--fuel-button-background-hover": "hsla(0, 0%, 40%, 1)", "--fuel-loader-background": "linear-gradient(to right, hsl(0, 0%, 20%) 8%, hsl(0, 0%, 25%) 18%, hsl(0, 0%, 20%) 33%)", "--fuel-green-3": "#0F2E1B", "--fuel-green-11": "#00DD75", "--fuel-blue-3": "#0D2847", "--fuel-blue-6": "#104D87", "--fuel-blue-11": "#70B9FF", "--fuel-blue-a3": "color(display-p3 0.1216 0.4627 1/0.219)", "--fuel-blue-a11": "color(display-p3 0.5176 0.7373 1/0.975)", "--fuel-gray-10": "#7b7b7b", "--fuel-gray-11": "#b4b4b4", "--fuel-gray-12": "#eee", "--fuel-separator-color": "rgb(165 165 165 / 13%)", "--fuel-black-color": "#141414" };
var yo = { light: mo, dark: fo };
var Ft = (e) => {
  let t = yo[e];
  return { ...po, ...t };
};
var go = { backgroundColor: "var(--fuel-overlay-background)", position: "fixed", inset: 0, animation: "fuelOverlayShow 150ms cubic-bezier(0.16, 1, 0.3, 1)" };
var Qt = ({ children: e }) => (0, import_jsx_runtime8.jsx)(Overlay, { style: go, asChild: true, children: e });
var Co = { position: "fixed", top: 0, left: 0, bottom: 0, right: 0, height: "100%", width: "100%", margin: 0, padding: 0, zIndex: 99, fontFamily: "var(--fuel-font-family)", fontSize: "var(--fuel-font-size)" };
var At = ({ style: e, children: t }) => (0, import_jsx_runtime8.jsx)("div", { className: "fuel-connectors", style: { ...Co, ...e }, children: t });
function $({ children: e, theme: t, open: r, onOpenChange: o }) {
  let [a, c] = (0, import_react4.useState)(false);
  return (0, import_react4.useEffect)(() => {
    c(true);
  }, []), a ? (0, import_jsx_runtime8.jsx)(Root, { open: r, onOpenChange: o, children: (0, import_jsx_runtime8.jsx)(Portal2, { children: (0, import_jsx_runtime8.jsx)(Qt, { children: (0, import_jsx_runtime8.jsx)(At, { style: Ft(t), children: e }) }) }) }) : null;
}
var bo = { ...Ie, gap: "12px", borderLeft: "2px solid", borderColor: "#F5CC00", marginLeft: "1rem", padding: "0.5em 2em", fontSize: "1em" };
var qt = ({ children: e }) => (0, import_jsx_runtime8.jsx)("div", { style: bo, children: e });
var xo = { fontWeight: 400, textAlign: "left", margin: 0, paddingInlineStart: "16px", lineHeight: "1.4em", opacity: 0.8, listStyleType: "disc" };
var Kt = ({ children: e, ...t }) => (0, import_jsx_runtime8.jsx)("ul", { style: xo, ...t, className: "fuel-connectors-disclaimer-list", children: e });
function Mt() {
  let { dialog: { connector: e, _startConnection: t, back: r } } = b();
  return e ? (0, import_jsx_runtime8.jsxs)("div", { children: [(0, import_jsx_runtime8.jsxs)(qt, { children: [(0, import_jsx_runtime8.jsx)("h2", { style: { ...Re, color: "var(--fuel-color-bold)", fontSize: "1.2em", textAlign: "left", margin: 0, padding: 0 }, children: "Non-Native Wallet" }), (0, import_jsx_runtime8.jsx)("p", { style: { ...ie, fontSize: "0.9em", textAlign: "left", margin: 0, padding: 0 }, children: "Fuel supports any wallet from Ethereum or Solana, but these wallets have limited functionality for now:" }), (0, import_jsx_runtime8.jsxs)(Kt, { children: [(0, import_jsx_runtime8.jsxs)("li", { children: [(0, import_jsx_runtime8.jsx)("span", { style: { fontSize: "0.9em", fontWeight: 600, color: "var(--fuel-gray-12)" }, children: "Limited Balance Visibility" }), (0, import_jsx_runtime8.jsx)("br", {}), (0, import_jsx_runtime8.jsx)("span", { style: { fontSize: "0.8em", color: "var(--fuel-gray-11)" }, children: "You cannot see balances natively in the wallet (e.g. Metamask). You must visit the Fuel Block Explorer to see balances." })] }), (0, import_jsx_runtime8.jsxs)("li", { style: { marginTop: 5, marginBottom: 5 }, children: [(0, import_jsx_runtime8.jsx)("span", { style: { fontSize: "0.9em", fontWeight: 600, color: "var(--fuel-gray-12)" }, children: "Signatures are Blind" }), (0, import_jsx_runtime8.jsx)("br", {}), (0, import_jsx_runtime8.jsx)("span", { style: { fontSize: "0.8em", color: "var(--fuel-gray-11)" }, children: "Ensure you only use trusted applications." })] }), (0, import_jsx_runtime8.jsxs)("li", { children: [(0, import_jsx_runtime8.jsx)("span", { style: { fontSize: "0.9em", fontWeight: 600, color: "var(--fuel-gray-12)" }, children: "No Multi-Sigs" }), (0, import_jsx_runtime8.jsx)("br", {}), (0, import_jsx_runtime8.jsx)("span", { style: { fontSize: "0.8em", color: "var(--fuel-gray-11)" }, children: "Multi-sigs and smart contract wallets (e.g. SAFE) are not supported." })] })] })] }), (0, import_jsx_runtime8.jsx)(F, { onClick: () => t(e), children: "Proceed" }), (0, import_jsx_runtime8.jsx)(Y, { onClick: () => r(), children: "Select a Native Wallet" })] }) : null;
}
var So = ({ route: e }) => {
  switch (e) {
    case "LIST":
      return (0, import_jsx_runtime8.jsx)(Pt, {});
    case "INSTALL":
      return (0, import_jsx_runtime8.jsx)(st, {});
    case "PREDICATE_EXTERNAL_DISCLAIMER":
      return (0, import_jsx_runtime8.jsx)(Mt, {});
    case "PREDICATE_ADDRESS_DISCLAIMER":
      return (0, import_jsx_runtime8.jsx)(Nt, {});
    case "CONNECTING":
      return (0, import_jsx_runtime8.jsx)(Rt, {});
    default:
      return null;
  }
};
function Wt() {
  let { theme: e, cancel: t, dialog: { isOpen: r, route: o, connector: a, back: c } } = b();
  return (0, import_jsx_runtime8.jsx)($, { open: r, theme: e, onOpenChange: (l) => {
    l || t();
  }, children: (0, import_jsx_runtime8.jsxs)(Z, { "data-connector": !!a, children: [(0, import_jsx_runtime8.jsxs)(le, { children: [(0, import_jsx_runtime8.jsx)(me, { size: 32, onClick: c, "data-connector": !!a }), (0, import_jsx_runtime8.jsx)(ue, { children: "Connect Wallet" }), (0, import_jsx_runtime8.jsx)(Close, { asChild: true, children: (0, import_jsx_runtime8.jsx)(fe, { size: 32, onClick: () => t() }) })] }), (0, import_jsx_runtime8.jsx)(pe, {}), (0, import_jsx_runtime8.jsx)(de, { children: (0, import_jsx_runtime8.jsx)(So, { route: o }) })] }) });
}
function zt({ size: e, ...t }) {
  return (0, import_jsx_runtime8.jsxs)("svg", { fill: "none", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 95 95", width: e, height: e, ...t, children: [(0, import_jsx_runtime8.jsx)("title", { children: "No Funds Icon" }), (0, import_jsx_runtime8.jsx)("path", { d: "M46.88 90.124C30.395 90.124 20 74.39 20 46.679 20 18.97 30.395 3 46.88 3s26.88 15.969 26.88 43.68c0 27.71-10.395 43.444-26.88 43.444Zm0-13.15c8.505 0 13.44-11.038 13.44-30.295 0-6.223-.525-11.624-1.47-16.086L39.005 72.511c2.1 2.936 4.725 4.462 7.875 4.462ZM33.44 46.678c0 6.106.525 11.507 1.47 15.852l19.845-41.918c-2.1-2.936-4.725-4.462-7.875-4.462-8.505 0-13.44 11.154-13.44 30.528Z", fill: "#EEE" }), (0, import_jsx_runtime8.jsx)("path", { d: "M67 91.281c5.523 0 10-4.876 10-10.89C77 74.376 72.523 69.5 67 69.5s-10 4.876-10 10.89c0 6.015 4.477 10.891 10 10.891Z", fill: "#000" }), (0, import_jsx_runtime8.jsx)("path", { d: "M67 91.281c5.523 0 10-4.876 10-10.89C77 74.376 72.523 69.5 67 69.5s-10 4.876-10 10.89c0 6.015 4.477 10.891 10 10.891Z", fill: "#627EEA" }), (0, import_jsx_runtime8.jsx)("path", { d: "M67 91.281c5.523 0 10-4.876 10-10.89C77 74.376 72.523 69.5 67 69.5s-10 4.876-10 10.89c0 6.015 4.477 10.891 10 10.891Z", fill: "url(#a)", style: { "mix-blend-mode": "soft-light" } }), (0, import_jsx_runtime8.jsx)("path", { d: "M67.166 73.13v5.368l4.166 2.027-4.166-7.395Z", fill: "#fff", fillOpacity: ".602" }), (0, import_jsx_runtime8.jsx)("path", { d: "M67.166 73.13 63 80.525l4.166-2.027V73.13Z", fill: "#fff" }), (0, import_jsx_runtime8.jsx)("path", { d: "M67.166 84.004v3.647l4.17-6.281-4.17 2.634Z", fill: "#fff", fillOpacity: ".602" }), (0, import_jsx_runtime8.jsx)("path", { d: "M67.166 87.65v-3.646L63 81.37l4.166 6.28Z", fill: "#fff" }), (0, import_jsx_runtime8.jsx)("path", { d: "m67.166 83.16 4.166-2.635-4.166-2.026v4.66Z", fill: "#fff", fillOpacity: ".2" }), (0, import_jsx_runtime8.jsx)("path", { d: "m63 80.525 4.166 2.634V78.5L63 80.525Z", fill: "#fff", fillOpacity: ".602" }), (0, import_jsx_runtime8.jsx)("defs", { children: (0, import_jsx_runtime8.jsxs)("linearGradient", { id: "a", x1: "67", y1: "69.5", x2: "67", y2: "91.281", gradientUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime8.jsx)("stop", { stopColor: "#fff", stopOpacity: ".5" }), (0, import_jsx_runtime8.jsx)("stop", { offset: "1", stopOpacity: ".5" })] }) })] });
}
function ve(e) {
  return { networks: (0, import_react4.useMemo)(() => e ? e.map((r) => r.chainId ? { ...$e.find((a) => a.chainId === r.chainId), ...r } : r) : [De], [e]) ?? [] };
}
function Vt({ theme: e }) {
  let { networks: t } = ve(), { provider: r } = P(), [o, a] = (0, import_react4.useState)(null);
  (0, import_react4.useEffect)(() => {
    let v = false;
    return (async () => {
      if (v) return;
      let q = await (r == null ? void 0 : r.getChainId()), w = t.find((K) => K.chainId === q);
      if (!v) if (w == null ? void 0 : w.bridgeURL) {
        let K = new URL(w.bridgeURL);
        K.searchParams.set("", "true"), a(K.toString());
      } else a(null);
    })(), () => {
      v = true;
    };
  }, [t, r]);
  let { isConnected: c, uiConfig: p, dialog: { isOpen: l } } = b(), { isSupportedNetwork: d } = be(), { account: f } = xe(), { balance: y } = Gt({ account: f }), [T, h] = (0, import_react4.useState)(false), x = (0, import_react4.useMemo)(() => T || l || !o || !p.suggestBridge || !c || !d ? false : !!(y == null ? void 0 : y.isZero()), [p, y, d, c, T, o, l]);
  return (0, import_jsx_runtime8.jsx)($, { open: x, theme: e, onOpenChange: (v) => {
    v || h(true);
  }, children: (0, import_jsx_runtime8.jsxs)(Z, { "data-connector": true, children: [(0, import_jsx_runtime8.jsxs)(le, { children: [(0, import_jsx_runtime8.jsx)(me, { size: 32, "data-connector": false }), (0, import_jsx_runtime8.jsx)(ue, { children: "Bridge Funds" }), (0, import_jsx_runtime8.jsx)(Close, { asChild: true, children: (0, import_jsx_runtime8.jsx)(fe, { size: 32 }) })] }), (0, import_jsx_runtime8.jsx)(pe, {}), (0, import_jsx_runtime8.jsx)(de, { children: (0, import_jsx_runtime8.jsxs)("div", { children: [(0, import_jsx_runtime8.jsx)(_, { children: (0, import_jsx_runtime8.jsx)(zt, { size: 100, theme: e }) }), (0, import_jsx_runtime8.jsxs)(A, { children: [(0, import_jsx_runtime8.jsxs)(z, { children: ["Bridge Funds ", (0, import_jsx_runtime8.jsx)("br", {}), " to Fuel Ignition"] }), (0, import_jsx_runtime8.jsx)(L, { children: "Looks like you don't have ETH balance, bridge funds to Fuel Ignition and use the application without stopping." })] }), (0, import_jsx_runtime8.jsx)(F, { href: o ?? "", target: "_blank", children: "Bridge now" }), (0, import_jsx_runtime8.jsx)(Y, { onClick: () => h(true), children: "Continue to application" })] }) })] }) });
}
var Se = ({ query: e } = {}) => {
  let { fuel: t } = u();
  return m("currentConnector", { queryKey: n.currentConnector(), queryFn: async () => await t.isConnected() ? t.currentConnector() ?? null : null, placeholderData: null, ...e });
};
var Q = (e) => {
  let { fuel: t } = u();
  return m("isConnected", { queryKey: n.isConnected(), queryFn: async () => {
    try {
      return await t.isConnected() || false;
    } catch {
      return false;
    }
  }, placeholderData: false, ...e == null ? void 0 : e.query, refetchInterval: 1e3 });
};
var Pe = (e) => {
  let { fuel: t } = u(), { isConnected: r } = Q();
  return m("network", { queryKey: n.currentNetwork(), queryFn: async () => {
    let o = await t.currentNetwork();
    if (!o && r) throw new Error("Network not found");
    return o;
  }, placeholderData: null, refetchOnMount: true, refetchInterval: (o) => !o.state.data || o.state.error ? 4e3 : false, enabled: r, ...e == null ? void 0 : e.query });
};
function be(e) {
  let { networks: t } = u(), { network: r } = Pe(), { isConnected: o } = Q(), { currentConnector: a } = Se();
  return m("isSupportedNetwork", { queryKey: n.isSupportedNetwork(a == null ? void 0 : a.name, t, r, o), queryFn: async () => {
    if (!a || !o || !r) return true;
    let c = r.chainId;
    return c == null && (c = await new Provider(r.url).getChainId()), !!t.find((p) => p.chainId === c);
  }, placeholderData: true, ...e });
}
var Zt = "0.8em";
var No = { position: "relative", padding: "calc(0.8em + 4px) 16px 0.8em 16px" };
var $t = ({ children: e }) => (0, import_jsx_runtime8.jsx)("div", { style: No, children: e });
var Do = { display: "flex", flexDirection: "column", alignItems: "center", gap: "var(--fuel-items-gap)" };
var Jt = ({ children: e }) => (0, import_jsx_runtime8.jsx)("div", { style: Do, children: e });
var Ro = { textAlign: "center", fontSize: "1.2em", fontWeight: 500, color: "var(--fuel-color-bold)", lineHeight: 1 };
var Xt = ({ children: e }) => (0, import_jsx_runtime8.jsx)("h2", { style: Ro, children: e });
var Io = { height: "1px", width: "100%", backgroundColor: "var(--fuel-separator-color)", margin: "10px 0", boxSizing: "border-box" };
var Me = () => (0, import_jsx_runtime8.jsx)("div", { style: Io });
var Fo = { margin: "20px 20px 0 20px", display: "flex", flexDirection: "column", alignItems: "center", gap: Zt, marginBottom: Zt };
var jt = ({ children: e }) => (0, import_jsx_runtime8.jsx)("div", { style: Fo, children: e });
var er = { fontWeight: 400, textAlign: "center", lineHeight: "1.2em", color: "var(--fuel-gray-11)", marginBottom: "10px", marginTop: "10px" };
var tr = ({ children: e }) => (0, import_jsx_runtime8.jsx)("p", { style: er, children: e });
var Eo = { ...er, marginBottom: "4px", marginTop: "4px" };
var Be = ({ children: e }) => (0, import_jsx_runtime8.jsx)("p", { style: Eo, children: e });
var Qo = { fontWeight: 400, textAlign: "center", lineHeight: "1.2em", opacity: 0.8, color: "var(--fuel-color-error)" };
var rr = ({ children: e }) => (0, import_jsx_runtime8.jsx)("div", { style: Qo, children: e });
var Oe = { width: "100%", height: "40px", display: "flex", borderRadius: "11px", textDecoration: "none", justifyContent: "center", alignItems: "center", margin: "0.4rem 0", fontSize: "0.875em", marginBottom: 0, color: "var(--fuel-black-color)" };
var or = (e) => (0, import_jsx_runtime8.jsx)("input", { style: Oe, ...e, className: "fuel-connectors-button-base fuel-connectors-button" });
var Ao = { ...Oe, backgroundColor: "var(--fuel-button-background)", color: "var(--fuel-color-bold)" };
var nr = (e) => (0, import_jsx_runtime8.jsx)("input", { style: Ao, ...e, className: "fuel-connectors-button-base fuel-connectors-button-disconnect" });
var Uo = { fontWeight: 400, textAlign: "center", lineHeight: 1, color: "var(--fuel-gray-11)" };
var ar = ({ children: e }) => (0, import_jsx_runtime8.jsx)("div", { style: Uo, children: e });
var qo = { ...Oe, marginBottom: 0 };
var ir = ({ children: e, ...t }) => (0, import_jsx_runtime8.jsx)("div", { style: qo, ...t, className: "fuel-connectors-button-base", children: e });
function sr({ theme: e }) {
  let { networks: t } = u(), { disconnect: r } = cr(), { currentConnector: o } = Se(), { isSupportedNetwork: a } = be(), { selectNetwork: c, isError: p, error: l, isPending: d } = lr(), { isConnected: f } = Q(), { data: y } = useQuery({ queryKey: ["chainName", t[0]], queryFn: async () => t[0].url ? (await new Provider(t[0].url).getChain()).name : "", placeholderData: "" });
  function T() {
    t[0].chainId != null && c({ chainId: t[0].chainId, url: t[0].url });
  }
  function h() {
    r();
  }
  function x() {
    return p && ((l == null ? void 0 : l.message) === "Method not implemented." || (l == null ? void 0 : l.message) === "Method not found") ? "The selected Wallet does not support switching networks, please switch manually in your wallet." : p ? (l == null ? void 0 : l.message) || "Failed to switch network" : "";
  }
  return t == null || !f ? null : (0, import_jsx_runtime8.jsx)($, { open: !a && !!y, theme: e, children: (0, import_jsx_runtime8.jsx)(Z, { "data-connector": !!o, onPointerDownOutside: (v) => {
    v.preventDefault();
  }, onEscapeKeyDown: (v) => {
    v.preventDefault();
  }, children: (0, import_jsx_runtime8.jsx)($t, { children: (0, import_jsx_runtime8.jsxs)(Jt, { children: [(0, import_jsx_runtime8.jsxs)(jt, { children: [(0, import_jsx_runtime8.jsx)(Xt, { children: "Network Switch Required" }), (0, import_jsx_runtime8.jsx)(tr, { children: "This app does not support the current connected network." }), y && (0, import_jsx_runtime8.jsxs)(import_jsx_runtime8.Fragment, { children: [(0, import_jsx_runtime8.jsx)(Be, { children: "Switch to:" }), (0, import_jsx_runtime8.jsx)(Be, { children: (0, import_jsx_runtime8.jsx)("span", { style: { fontWeight: "bold" }, children: y }) })] }), !!p && (0, import_jsx_runtime8.jsx)(rr, { children: x() })] }), !d && (0, import_jsx_runtime8.jsx)(or, { type: "button", disabled: d, onClick: T, value: "Switch Network" }), d && (0, import_jsx_runtime8.jsx)(ir, { children: (0, import_jsx_runtime8.jsx)(ge, { size: 26, color: "var(--fuel-loader-background)" }) }), (0, import_jsx_runtime8.jsxs)("div", { style: { display: "flex", flexDirection: "row", alignItems: "center", gap: "6px", width: "100%" }, children: [(0, import_jsx_runtime8.jsx)(Me, {}), (0, import_jsx_runtime8.jsx)(ar, { children: "or" }), (0, import_jsx_runtime8.jsx)(Me, {})] }), (0, import_jsx_runtime8.jsx)(nr, { type: "button", onClick: h, value: "Disconnect", color: "var(--fuel-border-color)" })] }) }) }) });
}
function Qc({ theme: e, children: t, fuelConfig: r, uiConfig: o, ui: a = true, networks: c }) {
  let p = e || "light", { networks: l } = ve(c), d = (0, import_react4.useMemo)(() => Object.assign({ suggestBridge: true }, o ?? {}), [o]);
  return a ? (0, import_jsx_runtime8.jsx)(qe, { fuelConfig: r, networks: l, children: (0, import_jsx_runtime8.jsxs)(tt, { theme: p, fuelConfig: r, uiConfig: d, children: [(0, import_jsx_runtime8.jsx)(Wt, {}), (0, import_jsx_runtime8.jsx)(sr, { theme: p }), d.suggestBridge && (0, import_jsx_runtime8.jsx)(Vt, { theme: p }), t] }) }) : (0, import_jsx_runtime8.jsx)(qe, { fuelConfig: r, networks: l, children: t });
}
var xe = (e) => {
  let { fuel: t } = u();
  return m("account", { queryKey: n.account(), queryFn: async () => {
    try {
      return await (t == null ? void 0 : t.currentAccount());
    } catch {
      return null;
    }
  }, placeholderData: null, ...e == null ? void 0 : e.query });
};
var $c = (e) => {
  let { fuel: t } = u();
  return m("accounts", { queryKey: n.accounts(), queryFn: async () => {
    try {
      return await t.accounts();
    } catch {
      return [];
    }
  }, placeholderData: [], ...e == null ? void 0 : e.query });
};
var rl = () => {
  let { fuel: e } = u(), { mutate: t, mutateAsync: r, ...o } = useMutation({ mutationKey: [oe.addAssets], mutationFn: async (a) => Array.isArray(a) ? e.addAssets(a) : e.addAsset(a) });
  return { addAssets: t, addAssetsAsync: r, ...o };
};
var cl = () => {
  let { fuel: e } = u(), { mutate: t, mutateAsync: r, ...o } = useMutation({ mutationKey: [oe.addNetwork], mutationFn: async (a) => e.addNetwork(a) });
  return { addNetwork: t, addNetworkAsync: r, ...o };
};
var fl = (e) => {
  let { fuel: t } = u();
  return m("assets", { queryKey: n.assets(), queryFn: async () => {
    try {
      return await t.assets();
    } catch {
      return [];
    }
  }, placeholderData: [], ...e == null ? void 0 : e.query });
};
function ur(e) {
  let { fuel: t, networks: r } = u(), { network: o } = Pe(), { account: a } = xe(), c = typeof e == "string" ? { account: e } : e ?? {};
  return m("wallet", { queryKey: n.wallet(a, o == null ? void 0 : o.url), queryFn: async () => {
    try {
      if (!a || !(o == null ? void 0 : o.url)) return null;
      await Address.fromString(a);
      let l = await t.getWallet(a), d = r.find((f) => f.chainId === o.chainId);
      if ((d == null ? void 0 : d.url) && d.url !== o.url) {
        let f = new Provider(d.url);
        l.connect(f);
      }
      return l;
    } catch {
      return null;
    }
  }, enabled: !!a && !!(o == null ? void 0 : o.url), placeholderData: null, ...c.query });
}
var P = (e) => {
  let { wallet: t } = ur();
  return { provider: (0, import_react4.useMemo)(() => t == null ? void 0 : t.provider, [t == null ? void 0 : t.provider, t == null ? void 0 : t.provider.url]) };
};
var Gt = ({ address: e, account: t, assetId: r, query: o }) => {
  let { provider: a } = P(), c = t ?? e ?? void 0, [p, l] = (0, import_react4.useState)();
  return (0, import_react4.useEffect)(() => {
    (async () => {
      let f = await (a == null ? void 0 : a.getChainId());
      l(f);
    })();
  }, [a]), m("balance", { queryKey: n.balance(c, r, p), queryFn: async () => {
    try {
      if (!a) throw new Error("Provider is needed");
      let d = r || await a.getBaseAssetId();
      return await a.getBalance(Address.fromString(c || ""), d) || null;
    } catch {
      return null;
    }
  }, placeholderData: null, enabled: !!a && !!c, ...o });
};
var Ml = (e) => {
  let { provider: t } = P();
  return m("chain", { queryKey: n.chain(), queryFn: async () => {
    try {
      return await (t == null ? void 0 : t.getChain()) || null;
    } catch {
      return null;
    }
  }, placeholderData: null, enabled: !!t, ...e == null ? void 0 : e.query });
};
var jo = (e) => "functions" in e;
var Yl = ({ contract: e, functionName: t, args: r }) => {
  var _a, _b;
  let o = jo(e), [a, c] = (0, import_react4.useState)(void 0);
  return (0, import_react4.useEffect)(() => {
    (async () => {
      var _a2;
      let l = await ((_a2 = e == null ? void 0 : e.provider) == null ? void 0 : _a2.getChainId());
      c(l);
    })();
  }, [e]), m("contractRead", { queryKey: n.contract(o ? (_a = e == null ? void 0 : e.id) == null ? void 0 : _a.toString() : (_b = e == null ? void 0 : e.address) == null ? void 0 : _b.toString(), a, r == null ? void 0 : r.toString()), queryFn: async () => {
    var _a2, _b2, _c, _d, _e, _f, _g;
    if (!(o ? !!e && "provider" in e : !!e.abi && !!e.address && !!e.provider)) throw new Error("Invalid input `contract` is required to read the contract");
    let l = o ? e : new Contract(e.address, e.abi, e.provider);
    if (!((_a2 = l == null ? void 0 : l.functions) == null ? void 0 : _a2[t])) throw new Error(`Function ${t || ""} not found on contract`);
    if (((_c = (_b2 = l.functions[t]).isReadOnly) == null ? void 0 : _c.call(_b2)) !== void 0 ? !l.functions[t].isReadOnly() : (_g = (_f = (_e = (_d = Object.values(l.interface.functions).find((f) => f.name === t)) == null ? void 0 : _d.attributes) == null ? void 0 : _e.find((f) => f.name === "storage")) == null ? void 0 : _f.arguments) == null ? void 0 : _g.includes("write")) throw new Error("Methods that write to storage should not be called with useContractRead");
    return r !== void 0 ? l.functions[t](r) : l.functions[t]();
  }, placeholderData: void 0 });
};
var cr = () => {
  let { fuel: e } = u(), { mutate: t, mutateAsync: r, ...o } = useMutation({ mutationFn: async () => e == null ? void 0 : e.disconnect() });
  return { disconnect: t, disconnectAsync: r, ...o };
};
var ru = (e) => {
  let { fuel: t } = u();
  return m("networks", { queryKey: n.networks(), queryFn: t.networks, placeholderData: [], ...e == null ? void 0 : e.query });
};
var tn = /^[v^~<>=]*?(\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+))?(?:-([\da-z\-]+(?:\.[\da-z\-]+)*))?(?:\+[\da-z\-]+(?:\.[\da-z\-]+)*)?)?)?$/i;
var We = (e) => {
  if (typeof e != "string") throw new TypeError("Invalid argument expected string");
  let t = e.match(tn);
  if (!t) throw new Error(`Invalid argument not valid semver ('${e}' received)`);
  return t.shift(), t;
};
var pr = (e) => e === "*" || e === "x" || e === "X";
var dr = (e) => {
  let t = parseInt(e, 10);
  return isNaN(t) ? e : t;
};
var rn = (e, t) => typeof e != typeof t ? [String(e), String(t)] : [e, t];
var on = (e, t) => {
  if (pr(e) || pr(t)) return 0;
  let [r, o] = rn(dr(e), dr(t));
  return r > o ? 1 : r < o ? -1 : 0;
};
var He = (e, t) => {
  for (let r = 0; r < Math.max(e.length, t.length); r++) {
    let o = on(e[r] || "0", t[r] || "0");
    if (o !== 0) return o;
  }
  return 0;
};
var mr = (e, t) => {
  let r = We(e), o = We(t), a = r.pop(), c = o.pop(), p = He(r, o);
  return p !== 0 ? p : a && c ? He(a.split("."), c.split(".")) : a || c ? a ? -1 : 1 : 0;
};
var ze = (e, t, r) => {
  nn(r);
  let o = mr(e, t);
  return yr[r].includes(o);
};
var yr = { ">": [1], ">=": [0, 1], "=": [0], "<=": [-1, 0], "<": [-1], "!=": [-1, 1] };
var fr = Object.keys(yr);
var nn = (e) => {
  if (fr.indexOf(e) === -1) throw new Error(`Invalid operator, expected one of ${fr.join("|")}`);
};
var bu = ({ version: e = "0.0.0", query: t } = {}) => {
  let { provider: r } = P(), o = m("nodeInfo", { queryKey: n.nodeInfo(r == null ? void 0 : r.url), queryFn: () => {
    try {
      return (r == null ? void 0 : r.fetchNode()) || null;
    } catch {
      return null;
    }
  }, placeholderData: null, enabled: !!r, ...t });
  return new Proxy(o, { get(a, c) {
    var _a, _b;
    return c === "isCompatible" ? ((_a = a.nodeInfo) == null ? void 0 : _a.nodeVersion) ? ze((_b = a.nodeInfo) == null ? void 0 : _b.nodeVersion, e, ">=") : null : Reflect.get(a, c);
  } });
};
var lr = () => {
  let { fuel: e } = u(), { mutate: t, mutateAsync: r, ...o } = useMutation({ mutationFn: e.selectNetwork });
  return { selectNetwork: t, selectNetworkAsync: r, ...o };
};
var Iu = () => {
  let { fuel: e } = u(), { mutate: t, mutateAsync: r, ...o } = useMutation({ mutationFn: ({ address: a, transaction: c }) => {
    let p = Address.fromDynamicInput(a).toString();
    return e.sendTransaction(p, c);
  } });
  return { sendTransaction: t, sendTransactionAsync: r, ...o };
};
var qu = (e) => {
  let { fuel: t } = u();
  return m("transaction", { queryKey: n.transaction(e), queryFn: async () => {
    try {
      let r = await (t == null ? void 0 : t.getProvider());
      return r ? await r.getTransaction(e || "") : null;
    } catch {
      return null;
    }
  }, placeholderData: null, enabled: !!e });
};
var we = (e) => {
  let { provider: t } = P();
  return m("chainId", { queryKey: n.chainId(), queryFn: async () => {
    try {
      return await (t == null ? void 0 : t.getChainId()) || null;
    } catch {
      return null;
    }
  }, placeholderData: null, enabled: !!t, ...e == null ? void 0 : e.query });
};
var Zu = ({ txId: e, query: t }) => {
  let { provider: r } = P(), { chainId: o } = we();
  return m("transactionReceipts", { queryKey: n.transactionReceipts(e, o), queryFn: async () => {
    try {
      if (!r) return null;
      let a = new TransactionResponse(e || "", r, await r.getChainId());
      if (!a) return null;
      let { receipts: c } = await a.waitForResult();
      return c || null;
    } catch {
      return null;
    }
  }, placeholderData: null, enabled: !!e, ...t });
};
var op = ({ txId: e = "", query: t = {} }) => {
  let { provider: r } = P(), { chainId: o } = we(), { name: a = "transactionResult", ...c } = t;
  return m(a, { queryKey: n.transactionResult(e, o), queryFn: async () => r && await new TransactionResponse(e, r, await r.getChainId()).waitForResult() || null, placeholderData: null, enabled: !!e, ...c });
};
export {
  Qc as FuelProvider,
  oe as MUTATION_KEYS,
  n as QUERY_KEYS,
  ne as isNativeConnector,
  xe as useAccount,
  $c as useAccounts,
  rl as useAddAssets,
  cl as useAddNetwork,
  fl as useAssets,
  Gt as useBalance,
  Ml as useChain,
  we as useChainId,
  Ze as useConnect,
  b as useConnectUI,
  Je as useConnectors,
  Yl as useContractRead,
  Se as useCurrentConnector,
  cr as useDisconnect,
  u as useFuel,
  Q as useIsConnected,
  be as useIsSupportedNetwork,
  m as useNamedQuery,
  Pe as useNetwork,
  ru as useNetworks,
  bu as useNodeInfo,
  P as useProvider,
  lr as useSelectNetwork,
  Iu as useSendTransaction,
  qu as useTransaction,
  Zu as useTransactionReceipts,
  op as useTransactionResult,
  ur as useWallet
};
//# sourceMappingURL=@fuels_react.js.map
