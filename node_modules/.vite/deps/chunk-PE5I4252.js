import {
  init_tslib_es6,
  require_cjs,
  tslib_es6_exports
} from "./chunk-A63EYCMG.js";
import {
  require_browser_ponyfill
} from "./chunk-CKWBFEDU.js";
import {
  require_events
} from "./chunk-NPY75PGV.js";
import {
  __commonJS,
  __esm,
  __export,
  __reExport,
  __toCommonJS,
  __toESM
} from "./chunk-ONY6HBPH.js";

// node_modules/quick-format-unescaped/index.js
var require_quick_format_unescaped = __commonJS({
  "node_modules/quick-format-unescaped/index.js"(exports, module) {
    "use strict";
    function tryStringify(o4) {
      try {
        return JSON.stringify(o4);
      } catch (e2) {
        return '"[Circular]"';
      }
    }
    module.exports = format;
    function format(f3, args, opts) {
      var ss = opts && opts.stringify || tryStringify;
      var offset = 1;
      if (typeof f3 === "object" && f3 !== null) {
        var len = args.length + offset;
        if (len === 1) return f3;
        var objects = new Array(len);
        objects[0] = ss(f3);
        for (var index = 1; index < len; index++) {
          objects[index] = ss(args[index]);
        }
        return objects.join(" ");
      }
      if (typeof f3 !== "string") {
        return f3;
      }
      var argLen = args.length;
      if (argLen === 0) return f3;
      var str = "";
      var a = 1 - offset;
      var lastPos = -1;
      var flen = f3 && f3.length || 0;
      for (var i2 = 0; i2 < flen; ) {
        if (f3.charCodeAt(i2) === 37 && i2 + 1 < flen) {
          lastPos = lastPos > -1 ? lastPos : 0;
          switch (f3.charCodeAt(i2 + 1)) {
            case 100:
            case 102:
              if (a >= argLen)
                break;
              if (args[a] == null) break;
              if (lastPos < i2)
                str += f3.slice(lastPos, i2);
              str += Number(args[a]);
              lastPos = i2 + 2;
              i2++;
              break;
            case 105:
              if (a >= argLen)
                break;
              if (args[a] == null) break;
              if (lastPos < i2)
                str += f3.slice(lastPos, i2);
              str += Math.floor(Number(args[a]));
              lastPos = i2 + 2;
              i2++;
              break;
            case 79:
            case 111:
            case 106:
              if (a >= argLen)
                break;
              if (args[a] === void 0) break;
              if (lastPos < i2)
                str += f3.slice(lastPos, i2);
              var type = typeof args[a];
              if (type === "string") {
                str += "'" + args[a] + "'";
                lastPos = i2 + 2;
                i2++;
                break;
              }
              if (type === "function") {
                str += args[a].name || "<anonymous>";
                lastPos = i2 + 2;
                i2++;
                break;
              }
              str += ss(args[a]);
              lastPos = i2 + 2;
              i2++;
              break;
            case 115:
              if (a >= argLen)
                break;
              if (lastPos < i2)
                str += f3.slice(lastPos, i2);
              str += String(args[a]);
              lastPos = i2 + 2;
              i2++;
              break;
            case 37:
              if (lastPos < i2)
                str += f3.slice(lastPos, i2);
              str += "%";
              lastPos = i2 + 2;
              i2++;
              a--;
              break;
          }
          ++a;
        }
        ++i2;
      }
      if (lastPos === -1)
        return f3;
      else if (lastPos < flen) {
        str += f3.slice(lastPos);
      }
      return str;
    }
  }
});

// node_modules/pino/browser.js
var require_browser = __commonJS({
  "node_modules/pino/browser.js"(exports, module) {
    "use strict";
    var format = require_quick_format_unescaped();
    module.exports = pino;
    var _console = pfGlobalThisOrFallback().console || {};
    var stdSerializers = {
      mapHttpRequest: mock,
      mapHttpResponse: mock,
      wrapRequestSerializer: passthrough,
      wrapResponseSerializer: passthrough,
      wrapErrorSerializer: passthrough,
      req: mock,
      res: mock,
      err: asErrValue
    };
    function shouldSerialize(serialize, serializers) {
      if (Array.isArray(serialize)) {
        const hasToFilter = serialize.filter(function(k4) {
          return k4 !== "!stdSerializers.err";
        });
        return hasToFilter;
      } else if (serialize === true) {
        return Object.keys(serializers);
      }
      return false;
    }
    function pino(opts) {
      opts = opts || {};
      opts.browser = opts.browser || {};
      const transmit2 = opts.browser.transmit;
      if (transmit2 && typeof transmit2.send !== "function") {
        throw Error("pino: transmit option must have a send function");
      }
      const proto = opts.browser.write || _console;
      if (opts.browser.write) opts.browser.asObject = true;
      const serializers = opts.serializers || {};
      const serialize = shouldSerialize(opts.browser.serialize, serializers);
      let stdErrSerialize = opts.browser.serialize;
      if (Array.isArray(opts.browser.serialize) && opts.browser.serialize.indexOf("!stdSerializers.err") > -1) stdErrSerialize = false;
      const levels = ["error", "fatal", "warn", "info", "debug", "trace"];
      if (typeof proto === "function") {
        proto.error = proto.fatal = proto.warn = proto.info = proto.debug = proto.trace = proto;
      }
      if (opts.enabled === false) opts.level = "silent";
      const level = opts.level || "info";
      const logger = Object.create(proto);
      if (!logger.log) logger.log = noop;
      Object.defineProperty(logger, "levelVal", {
        get: getLevelVal
      });
      Object.defineProperty(logger, "level", {
        get: getLevel,
        set: setLevel
      });
      const setOpts = {
        transmit: transmit2,
        serialize,
        asObject: opts.browser.asObject,
        levels,
        timestamp: getTimeFunction(opts)
      };
      logger.levels = pino.levels;
      logger.level = level;
      logger.setMaxListeners = logger.getMaxListeners = logger.emit = logger.addListener = logger.on = logger.prependListener = logger.once = logger.prependOnceListener = logger.removeListener = logger.removeAllListeners = logger.listeners = logger.listenerCount = logger.eventNames = logger.write = logger.flush = noop;
      logger.serializers = serializers;
      logger._serialize = serialize;
      logger._stdErrSerialize = stdErrSerialize;
      logger.child = child;
      if (transmit2) logger._logEvent = createLogEventShape();
      function getLevelVal() {
        return this.level === "silent" ? Infinity : this.levels.values[this.level];
      }
      function getLevel() {
        return this._level;
      }
      function setLevel(level2) {
        if (level2 !== "silent" && !this.levels.values[level2]) {
          throw Error("unknown level " + level2);
        }
        this._level = level2;
        set2(setOpts, logger, "error", "log");
        set2(setOpts, logger, "fatal", "error");
        set2(setOpts, logger, "warn", "error");
        set2(setOpts, logger, "info", "log");
        set2(setOpts, logger, "debug", "log");
        set2(setOpts, logger, "trace", "log");
      }
      function child(bindings, childOptions) {
        if (!bindings) {
          throw new Error("missing bindings for child Pino");
        }
        childOptions = childOptions || {};
        if (serialize && bindings.serializers) {
          childOptions.serializers = bindings.serializers;
        }
        const childOptionsSerializers = childOptions.serializers;
        if (serialize && childOptionsSerializers) {
          var childSerializers = Object.assign({}, serializers, childOptionsSerializers);
          var childSerialize = opts.browser.serialize === true ? Object.keys(childSerializers) : serialize;
          delete bindings.serializers;
          applySerializers([bindings], childSerialize, childSerializers, this._stdErrSerialize);
        }
        function Child(parent) {
          this._childLevel = (parent._childLevel | 0) + 1;
          this.error = bind(parent, bindings, "error");
          this.fatal = bind(parent, bindings, "fatal");
          this.warn = bind(parent, bindings, "warn");
          this.info = bind(parent, bindings, "info");
          this.debug = bind(parent, bindings, "debug");
          this.trace = bind(parent, bindings, "trace");
          if (childSerializers) {
            this.serializers = childSerializers;
            this._serialize = childSerialize;
          }
          if (transmit2) {
            this._logEvent = createLogEventShape(
              [].concat(parent._logEvent.bindings, bindings)
            );
          }
        }
        Child.prototype = this;
        return new Child(this);
      }
      return logger;
    }
    pino.levels = {
      values: {
        fatal: 60,
        error: 50,
        warn: 40,
        info: 30,
        debug: 20,
        trace: 10
      },
      labels: {
        10: "trace",
        20: "debug",
        30: "info",
        40: "warn",
        50: "error",
        60: "fatal"
      }
    };
    pino.stdSerializers = stdSerializers;
    pino.stdTimeFunctions = Object.assign({}, { nullTime, epochTime, unixTime, isoTime });
    function set2(opts, logger, level, fallback) {
      const proto = Object.getPrototypeOf(logger);
      logger[level] = logger.levelVal > logger.levels.values[level] ? noop : proto[level] ? proto[level] : _console[level] || _console[fallback] || noop;
      wrap(opts, logger, level);
    }
    function wrap(opts, logger, level) {
      if (!opts.transmit && logger[level] === noop) return;
      logger[level] = /* @__PURE__ */ function(write) {
        return function LOG() {
          const ts = opts.timestamp();
          const args = new Array(arguments.length);
          const proto = Object.getPrototypeOf && Object.getPrototypeOf(this) === _console ? _console : this;
          for (var i2 = 0; i2 < args.length; i2++) args[i2] = arguments[i2];
          if (opts.serialize && !opts.asObject) {
            applySerializers(args, this._serialize, this.serializers, this._stdErrSerialize);
          }
          if (opts.asObject) write.call(proto, asObject(this, level, args, ts));
          else write.apply(proto, args);
          if (opts.transmit) {
            const transmitLevel = opts.transmit.level || logger.level;
            const transmitValue = pino.levels.values[transmitLevel];
            const methodValue = pino.levels.values[level];
            if (methodValue < transmitValue) return;
            transmit(this, {
              ts,
              methodLevel: level,
              methodValue,
              transmitLevel,
              transmitValue: pino.levels.values[opts.transmit.level || logger.level],
              send: opts.transmit.send,
              val: logger.levelVal
            }, args);
          }
        };
      }(logger[level]);
    }
    function asObject(logger, level, args, ts) {
      if (logger._serialize) applySerializers(args, logger._serialize, logger.serializers, logger._stdErrSerialize);
      const argsCloned = args.slice();
      let msg = argsCloned[0];
      const o4 = {};
      if (ts) {
        o4.time = ts;
      }
      o4.level = pino.levels.values[level];
      let lvl = (logger._childLevel | 0) + 1;
      if (lvl < 1) lvl = 1;
      if (msg !== null && typeof msg === "object") {
        while (lvl-- && typeof argsCloned[0] === "object") {
          Object.assign(o4, argsCloned.shift());
        }
        msg = argsCloned.length ? format(argsCloned.shift(), argsCloned) : void 0;
      } else if (typeof msg === "string") msg = format(argsCloned.shift(), argsCloned);
      if (msg !== void 0) o4.msg = msg;
      return o4;
    }
    function applySerializers(args, serialize, serializers, stdErrSerialize) {
      for (const i2 in args) {
        if (stdErrSerialize && args[i2] instanceof Error) {
          args[i2] = pino.stdSerializers.err(args[i2]);
        } else if (typeof args[i2] === "object" && !Array.isArray(args[i2])) {
          for (const k4 in args[i2]) {
            if (serialize && serialize.indexOf(k4) > -1 && k4 in serializers) {
              args[i2][k4] = serializers[k4](args[i2][k4]);
            }
          }
        }
      }
    }
    function bind(parent, bindings, level) {
      return function() {
        const args = new Array(1 + arguments.length);
        args[0] = bindings;
        for (var i2 = 1; i2 < args.length; i2++) {
          args[i2] = arguments[i2 - 1];
        }
        return parent[level].apply(this, args);
      };
    }
    function transmit(logger, opts, args) {
      const send = opts.send;
      const ts = opts.ts;
      const methodLevel = opts.methodLevel;
      const methodValue = opts.methodValue;
      const val = opts.val;
      const bindings = logger._logEvent.bindings;
      applySerializers(
        args,
        logger._serialize || Object.keys(logger.serializers),
        logger.serializers,
        logger._stdErrSerialize === void 0 ? true : logger._stdErrSerialize
      );
      logger._logEvent.ts = ts;
      logger._logEvent.messages = args.filter(function(arg) {
        return bindings.indexOf(arg) === -1;
      });
      logger._logEvent.level.label = methodLevel;
      logger._logEvent.level.value = methodValue;
      send(methodLevel, logger._logEvent, val);
      logger._logEvent = createLogEventShape(bindings);
    }
    function createLogEventShape(bindings) {
      return {
        ts: 0,
        messages: [],
        bindings: bindings || [],
        level: { label: "", value: 0 }
      };
    }
    function asErrValue(err) {
      const obj = {
        type: err.constructor.name,
        msg: err.message,
        stack: err.stack
      };
      for (const key in err) {
        if (obj[key] === void 0) {
          obj[key] = err[key];
        }
      }
      return obj;
    }
    function getTimeFunction(opts) {
      if (typeof opts.timestamp === "function") {
        return opts.timestamp;
      }
      if (opts.timestamp === false) {
        return nullTime;
      }
      return epochTime;
    }
    function mock() {
      return {};
    }
    function passthrough(a) {
      return a;
    }
    function noop() {
    }
    function nullTime() {
      return false;
    }
    function epochTime() {
      return Date.now();
    }
    function unixTime() {
      return Math.round(Date.now() / 1e3);
    }
    function isoTime() {
      return new Date(Date.now()).toISOString();
    }
    function pfGlobalThisOrFallback() {
      function defd(o4) {
        return typeof o4 !== "undefined" && o4;
      }
      try {
        if (typeof globalThis !== "undefined") return globalThis;
        Object.defineProperty(Object.prototype, "globalThis", {
          get: function() {
            delete Object.prototype.globalThis;
            return this.globalThis = this;
          },
          configurable: true
        });
        return globalThis;
      } catch (e2) {
        return defd(self) || defd(window) || defd(this) || {};
      }
    }
  }
});

// node_modules/@walletconnect/environment/dist/cjs/crypto.js
var require_crypto = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBrowserCryptoAvailable = exports.getSubtleCrypto = exports.getBrowerCrypto = void 0;
    function getBrowerCrypto() {
      return (global === null || global === void 0 ? void 0 : global.crypto) || (global === null || global === void 0 ? void 0 : global.msCrypto) || {};
    }
    exports.getBrowerCrypto = getBrowerCrypto;
    function getSubtleCrypto() {
      const browserCrypto = getBrowerCrypto();
      return browserCrypto.subtle || browserCrypto.webkitSubtle;
    }
    exports.getSubtleCrypto = getSubtleCrypto;
    function isBrowserCryptoAvailable() {
      return !!getBrowerCrypto() && !!getSubtleCrypto();
    }
    exports.isBrowserCryptoAvailable = isBrowserCryptoAvailable;
  }
});

// node_modules/@walletconnect/environment/dist/cjs/env.js
var require_env = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/env.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBrowser = exports.isNode = exports.isReactNative = void 0;
    function isReactNative() {
      return typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative";
    }
    exports.isReactNative = isReactNative;
    function isNode2() {
      return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
    }
    exports.isNode = isNode2;
    function isBrowser() {
      return !isReactNative() && !isNode2();
    }
    exports.isBrowser = isBrowser;
  }
});

// node_modules/@walletconnect/environment/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_crypto(), exports);
    tslib_1.__exportStar(require_env(), exports);
  }
});

// node_modules/@walletconnect/events/dist/esm/events.js
var IEvents;
var init_events = __esm({
  "node_modules/@walletconnect/events/dist/esm/events.js"() {
    IEvents = class {
    };
  }
});

// node_modules/@walletconnect/events/dist/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  IEvents: () => IEvents
});
var init_esm = __esm({
  "node_modules/@walletconnect/events/dist/esm/index.js"() {
    init_events();
  }
});

// node_modules/ws/browser.js
var require_browser2 = __commonJS({
  "node_modules/ws/browser.js"(exports, module) {
    "use strict";
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/@walletconnect/logger/dist/index.es.js
var import_pino = __toESM(require_browser());
var import_pino2 = __toESM(require_browser());

// node_modules/@walletconnect/safe-json/dist/esm/index.js
var JSONStringify = (data) => JSON.stringify(data, (_3, value) => typeof value === "bigint" ? value.toString() + "n" : value);
var JSONParse = (json) => {
  const numbersBiggerThanMaxInt = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g;
  const serializedData = json.replace(numbersBiggerThanMaxInt, '$1"$2n"$3');
  return JSON.parse(serializedData, (_3, value) => {
    const isCustomFormatBigInt = typeof value === "string" && value.match(/^\d+n$/);
    if (isCustomFormatBigInt)
      return BigInt(value.substring(0, value.length - 1));
    return value;
  });
};
function safeJsonParse(value) {
  if (typeof value !== "string") {
    throw new Error(`Cannot safe json parse value of type ${typeof value}`);
  }
  try {
    return JSONParse(value);
  } catch (_a) {
    return value;
  }
}
function safeJsonStringify(value) {
  return typeof value === "string" ? value : JSONStringify(value) || "";
}

// node_modules/@walletconnect/logger/dist/index.es.js
var c = { level: "info" };
var n = "custom_context";
var l = 1e3 * 1024;
var O = class {
  constructor(e2) {
    this.nodeValue = e2, this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length, this.next = null;
  }
  get value() {
    return this.nodeValue;
  }
  get size() {
    return this.sizeInBytes;
  }
};
var d = class {
  constructor(e2) {
    this.head = null, this.tail = null, this.lengthInNodes = 0, this.maxSizeInBytes = e2, this.sizeInBytes = 0;
  }
  append(e2) {
    const t = new O(e2);
    if (t.size > this.maxSizeInBytes) throw new Error(`[LinkedList] Value too big to insert into list: ${e2} with size ${t.size}`);
    for (; this.size + t.size > this.maxSizeInBytes; ) this.shift();
    this.head ? (this.tail && (this.tail.next = t), this.tail = t) : (this.head = t, this.tail = t), this.lengthInNodes++, this.sizeInBytes += t.size;
  }
  shift() {
    if (!this.head) return;
    const e2 = this.head;
    this.head = this.head.next, this.head || (this.tail = null), this.lengthInNodes--, this.sizeInBytes -= e2.size;
  }
  toArray() {
    const e2 = [];
    let t = this.head;
    for (; t !== null; ) e2.push(t.value), t = t.next;
    return e2;
  }
  get length() {
    return this.lengthInNodes;
  }
  get size() {
    return this.sizeInBytes;
  }
  toOrderedArray() {
    return Array.from(this);
  }
  [Symbol.iterator]() {
    let e2 = this.head;
    return { next: () => {
      if (!e2) return { done: true, value: null };
      const t = e2.value;
      return e2 = e2.next, { done: false, value: t };
    } };
  }
};
var L = class {
  constructor(e2, t = l) {
    this.level = e2 ?? "error", this.levelValue = import_pino.levels.values[this.level], this.MAX_LOG_SIZE_IN_BYTES = t, this.logs = new d(this.MAX_LOG_SIZE_IN_BYTES);
  }
  forwardToConsole(e2, t) {
    t === import_pino.levels.values.error ? console.error(e2) : t === import_pino.levels.values.warn ? console.warn(e2) : t === import_pino.levels.values.debug ? console.debug(e2) : t === import_pino.levels.values.trace ? console.trace(e2) : console.log(e2);
  }
  appendToLogs(e2) {
    this.logs.append(safeJsonStringify({ timestamp: (/* @__PURE__ */ new Date()).toISOString(), log: e2 }));
    const t = typeof e2 == "string" ? JSON.parse(e2).level : e2.level;
    t >= this.levelValue && this.forwardToConsole(e2, t);
  }
  getLogs() {
    return this.logs;
  }
  clearLogs() {
    this.logs = new d(this.MAX_LOG_SIZE_IN_BYTES);
  }
  getLogArray() {
    return Array.from(this.logs);
  }
  logsToBlob(e2) {
    const t = this.getLogArray();
    return t.push(safeJsonStringify({ extraMetadata: e2 })), new Blob(t, { type: "application/json" });
  }
};
var m = class {
  constructor(e2, t = l) {
    this.baseChunkLogger = new L(e2, t);
  }
  write(e2) {
    this.baseChunkLogger.appendToLogs(e2);
  }
  getLogs() {
    return this.baseChunkLogger.getLogs();
  }
  clearLogs() {
    this.baseChunkLogger.clearLogs();
  }
  getLogArray() {
    return this.baseChunkLogger.getLogArray();
  }
  logsToBlob(e2) {
    return this.baseChunkLogger.logsToBlob(e2);
  }
  downloadLogsBlobInBrowser(e2) {
    const t = URL.createObjectURL(this.logsToBlob(e2)), o4 = document.createElement("a");
    o4.href = t, o4.download = `walletconnect-logs-${(/* @__PURE__ */ new Date()).toISOString()}.txt`, document.body.appendChild(o4), o4.click(), document.body.removeChild(o4), URL.revokeObjectURL(t);
  }
};
var B = class {
  constructor(e2, t = l) {
    this.baseChunkLogger = new L(e2, t);
  }
  write(e2) {
    this.baseChunkLogger.appendToLogs(e2);
  }
  getLogs() {
    return this.baseChunkLogger.getLogs();
  }
  clearLogs() {
    this.baseChunkLogger.clearLogs();
  }
  getLogArray() {
    return this.baseChunkLogger.getLogArray();
  }
  logsToBlob(e2) {
    return this.baseChunkLogger.logsToBlob(e2);
  }
};
var x = Object.defineProperty;
var S = Object.defineProperties;
var _ = Object.getOwnPropertyDescriptors;
var p = Object.getOwnPropertySymbols;
var T = Object.prototype.hasOwnProperty;
var z = Object.prototype.propertyIsEnumerable;
var f = (r2, e2, t) => e2 in r2 ? x(r2, e2, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e2] = t;
var i = (r2, e2) => {
  for (var t in e2 || (e2 = {})) T.call(e2, t) && f(r2, t, e2[t]);
  if (p) for (var t of p(e2)) z.call(e2, t) && f(r2, t, e2[t]);
  return r2;
};
var g = (r2, e2) => S(r2, _(e2));
function k(r2) {
  return g(i({}, r2), { level: (r2 == null ? void 0 : r2.level) || c.level });
}
function v(r2, e2 = n) {
  return r2[e2] || "";
}
function b(r2, e2, t = n) {
  return r2[t] = e2, r2;
}
function y(r2, e2 = n) {
  let t = "";
  return typeof r2.bindings > "u" ? t = v(r2, e2) : t = r2.bindings().context || "", t;
}
function w(r2, e2, t = n) {
  const o4 = y(r2, t);
  return o4.trim() ? `${o4}/${e2}` : e2;
}
function E(r2, e2, t = n) {
  const o4 = w(r2, e2, t), a = r2.child({ context: o4 });
  return b(a, o4, t);
}
function C(r2) {
  var e2, t;
  const o4 = new m((e2 = r2.opts) == null ? void 0 : e2.level, r2.maxSizeInBytes);
  return { logger: (0, import_pino.default)(g(i({}, r2.opts), { level: "trace", browser: g(i({}, (t = r2.opts) == null ? void 0 : t.browser), { write: (a) => o4.write(a) }) })), chunkLoggerController: o4 };
}
function I(r2) {
  var e2;
  const t = new B((e2 = r2.opts) == null ? void 0 : e2.level, r2.maxSizeInBytes);
  return { logger: (0, import_pino.default)(g(i({}, r2.opts), { level: "trace" }), t), chunkLoggerController: t };
}
function A(r2) {
  return typeof r2.loggerOverride < "u" && typeof r2.loggerOverride != "string" ? { logger: r2.loggerOverride, chunkLoggerController: null } : typeof window < "u" ? C(r2) : I(r2);
}

// node_modules/@walletconnect/relay-auth/dist/index.es.js
var import_time = __toESM(require_cjs());
function En(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function fe(t, ...e2) {
  if (!En(t)) throw new Error("Uint8Array expected");
  if (e2.length > 0 && !e2.includes(t.length)) throw new Error("Uint8Array expected of length " + e2 + ", got length=" + t.length);
}
function De(t, e2 = true) {
  if (t.destroyed) throw new Error("Hash instance has been destroyed");
  if (e2 && t.finished) throw new Error("Hash#digest() has already been called");
}
function gn(t, e2) {
  fe(t);
  const n3 = e2.outputLen;
  if (t.length < n3) throw new Error("digestInto() expects output buffer of length at least " + n3);
}
var it = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
var _t = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength);
function yn(t) {
  if (typeof t != "string") throw new Error("utf8ToBytes expected string, got " + typeof t);
  return new Uint8Array(new TextEncoder().encode(t));
}
function de(t) {
  return typeof t == "string" && (t = yn(t)), fe(t), t;
}
var xn = class {
  clone() {
    return this._cloneInto();
  }
};
function Bn(t) {
  const e2 = (r2) => t().update(de(r2)).digest(), n3 = t();
  return e2.outputLen = n3.outputLen, e2.blockLen = n3.blockLen, e2.create = () => t(), e2;
}
function he(t = 32) {
  if (it && typeof it.getRandomValues == "function") return it.getRandomValues(new Uint8Array(t));
  if (it && typeof it.randomBytes == "function") return it.randomBytes(t);
  throw new Error("crypto.getRandomValues must be defined");
}
function Cn(t, e2, n3, r2) {
  if (typeof t.setBigUint64 == "function") return t.setBigUint64(e2, n3, r2);
  const o4 = BigInt(32), s2 = BigInt(4294967295), a = Number(n3 >> o4 & s2), u = Number(n3 & s2), i2 = r2 ? 4 : 0, D2 = r2 ? 0 : 4;
  t.setUint32(e2 + i2, a, r2), t.setUint32(e2 + D2, u, r2);
}
var An = class extends xn {
  constructor(e2, n3, r2, o4) {
    super(), this.blockLen = e2, this.outputLen = n3, this.padOffset = r2, this.isLE = o4, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(e2), this.view = _t(this.buffer);
  }
  update(e2) {
    De(this);
    const { view: n3, buffer: r2, blockLen: o4 } = this;
    e2 = de(e2);
    const s2 = e2.length;
    for (let a = 0; a < s2; ) {
      const u = Math.min(o4 - this.pos, s2 - a);
      if (u === o4) {
        const i2 = _t(e2);
        for (; o4 <= s2 - a; a += o4) this.process(i2, a);
        continue;
      }
      r2.set(e2.subarray(a, a + u), this.pos), this.pos += u, a += u, this.pos === o4 && (this.process(n3, 0), this.pos = 0);
    }
    return this.length += e2.length, this.roundClean(), this;
  }
  digestInto(e2) {
    De(this), gn(e2, this), this.finished = true;
    const { buffer: n3, view: r2, blockLen: o4, isLE: s2 } = this;
    let { pos: a } = this;
    n3[a++] = 128, this.buffer.subarray(a).fill(0), this.padOffset > o4 - a && (this.process(r2, 0), a = 0);
    for (let l4 = a; l4 < o4; l4++) n3[l4] = 0;
    Cn(r2, o4 - 8, BigInt(this.length * 8), s2), this.process(r2, 0);
    const u = _t(e2), i2 = this.outputLen;
    if (i2 % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const D2 = i2 / 4, c5 = this.get();
    if (D2 > c5.length) throw new Error("_sha2: outputLen bigger than state");
    for (let l4 = 0; l4 < D2; l4++) u.setUint32(4 * l4, c5[l4], s2);
  }
  digest() {
    const { buffer: e2, outputLen: n3 } = this;
    this.digestInto(e2);
    const r2 = e2.slice(0, n3);
    return this.destroy(), r2;
  }
  _cloneInto(e2) {
    e2 || (e2 = new this.constructor()), e2.set(...this.get());
    const { blockLen: n3, buffer: r2, length: o4, finished: s2, destroyed: a, pos: u } = this;
    return e2.length = o4, e2.pos = u, e2.finished = s2, e2.destroyed = a, o4 % n3 && e2.buffer.set(r2), e2;
  }
};
var wt = BigInt(2 ** 32 - 1);
var St = BigInt(32);
function le(t, e2 = false) {
  return e2 ? { h: Number(t & wt), l: Number(t >> St & wt) } : { h: Number(t >> St & wt) | 0, l: Number(t & wt) | 0 };
}
function mn(t, e2 = false) {
  let n3 = new Uint32Array(t.length), r2 = new Uint32Array(t.length);
  for (let o4 = 0; o4 < t.length; o4++) {
    const { h: s2, l: a } = le(t[o4], e2);
    [n3[o4], r2[o4]] = [s2, a];
  }
  return [n3, r2];
}
var _n = (t, e2) => BigInt(t >>> 0) << St | BigInt(e2 >>> 0);
var Sn = (t, e2, n3) => t >>> n3;
var vn = (t, e2, n3) => t << 32 - n3 | e2 >>> n3;
var In = (t, e2, n3) => t >>> n3 | e2 << 32 - n3;
var Un = (t, e2, n3) => t << 32 - n3 | e2 >>> n3;
var Tn = (t, e2, n3) => t << 64 - n3 | e2 >>> n3 - 32;
var Fn = (t, e2, n3) => t >>> n3 - 32 | e2 << 64 - n3;
var Nn = (t, e2) => e2;
var Ln = (t, e2) => t;
var On = (t, e2, n3) => t << n3 | e2 >>> 32 - n3;
var Hn = (t, e2, n3) => e2 << n3 | t >>> 32 - n3;
var zn = (t, e2, n3) => e2 << n3 - 32 | t >>> 64 - n3;
var Mn = (t, e2, n3) => t << n3 - 32 | e2 >>> 64 - n3;
function qn(t, e2, n3, r2) {
  const o4 = (e2 >>> 0) + (r2 >>> 0);
  return { h: t + n3 + (o4 / 2 ** 32 | 0) | 0, l: o4 | 0 };
}
var $n = (t, e2, n3) => (t >>> 0) + (e2 >>> 0) + (n3 >>> 0);
var kn = (t, e2, n3, r2) => e2 + n3 + r2 + (t / 2 ** 32 | 0) | 0;
var Rn = (t, e2, n3, r2) => (t >>> 0) + (e2 >>> 0) + (n3 >>> 0) + (r2 >>> 0);
var jn = (t, e2, n3, r2, o4) => e2 + n3 + r2 + o4 + (t / 2 ** 32 | 0) | 0;
var Zn = (t, e2, n3, r2, o4) => (t >>> 0) + (e2 >>> 0) + (n3 >>> 0) + (r2 >>> 0) + (o4 >>> 0);
var Gn = (t, e2, n3, r2, o4, s2) => e2 + n3 + r2 + o4 + s2 + (t / 2 ** 32 | 0) | 0;
var x2 = { fromBig: le, split: mn, toBig: _n, shrSH: Sn, shrSL: vn, rotrSH: In, rotrSL: Un, rotrBH: Tn, rotrBL: Fn, rotr32H: Nn, rotr32L: Ln, rotlSH: On, rotlSL: Hn, rotlBH: zn, rotlBL: Mn, add: qn, add3L: $n, add3H: kn, add4L: Rn, add4H: jn, add5H: Gn, add5L: Zn };
var [Vn, Yn] = (() => x2.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((t) => BigInt(t))))();
var P = new Uint32Array(80);
var Q = new Uint32Array(80);
var Jn = class extends An {
  constructor() {
    super(128, 64, 16, false), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  get() {
    const { Ah: e2, Al: n3, Bh: r2, Bl: o4, Ch: s2, Cl: a, Dh: u, Dl: i2, Eh: D2, El: c5, Fh: l4, Fl: p3, Gh: w3, Gl: h3, Hh: g3, Hl: S2 } = this;
    return [e2, n3, r2, o4, s2, a, u, i2, D2, c5, l4, p3, w3, h3, g3, S2];
  }
  set(e2, n3, r2, o4, s2, a, u, i2, D2, c5, l4, p3, w3, h3, g3, S2) {
    this.Ah = e2 | 0, this.Al = n3 | 0, this.Bh = r2 | 0, this.Bl = o4 | 0, this.Ch = s2 | 0, this.Cl = a | 0, this.Dh = u | 0, this.Dl = i2 | 0, this.Eh = D2 | 0, this.El = c5 | 0, this.Fh = l4 | 0, this.Fl = p3 | 0, this.Gh = w3 | 0, this.Gl = h3 | 0, this.Hh = g3 | 0, this.Hl = S2 | 0;
  }
  process(e2, n3) {
    for (let d3 = 0; d3 < 16; d3++, n3 += 4) P[d3] = e2.getUint32(n3), Q[d3] = e2.getUint32(n3 += 4);
    for (let d3 = 16; d3 < 80; d3++) {
      const m3 = P[d3 - 15] | 0, F = Q[d3 - 15] | 0, q = x2.rotrSH(m3, F, 1) ^ x2.rotrSH(m3, F, 8) ^ x2.shrSH(m3, F, 7), z3 = x2.rotrSL(m3, F, 1) ^ x2.rotrSL(m3, F, 8) ^ x2.shrSL(m3, F, 7), I2 = P[d3 - 2] | 0, O4 = Q[d3 - 2] | 0, ot = x2.rotrSH(I2, O4, 19) ^ x2.rotrBH(I2, O4, 61) ^ x2.shrSH(I2, O4, 6), tt = x2.rotrSL(I2, O4, 19) ^ x2.rotrBL(I2, O4, 61) ^ x2.shrSL(I2, O4, 6), st = x2.add4L(z3, tt, Q[d3 - 7], Q[d3 - 16]), at = x2.add4H(st, q, ot, P[d3 - 7], P[d3 - 16]);
      P[d3] = at | 0, Q[d3] = st | 0;
    }
    let { Ah: r2, Al: o4, Bh: s2, Bl: a, Ch: u, Cl: i2, Dh: D2, Dl: c5, Eh: l4, El: p3, Fh: w3, Fl: h3, Gh: g3, Gl: S2, Hh: v3, Hl: L3 } = this;
    for (let d3 = 0; d3 < 80; d3++) {
      const m3 = x2.rotrSH(l4, p3, 14) ^ x2.rotrSH(l4, p3, 18) ^ x2.rotrBH(l4, p3, 41), F = x2.rotrSL(l4, p3, 14) ^ x2.rotrSL(l4, p3, 18) ^ x2.rotrBL(l4, p3, 41), q = l4 & w3 ^ ~l4 & g3, z3 = p3 & h3 ^ ~p3 & S2, I2 = x2.add5L(L3, F, z3, Yn[d3], Q[d3]), O4 = x2.add5H(I2, v3, m3, q, Vn[d3], P[d3]), ot = I2 | 0, tt = x2.rotrSH(r2, o4, 28) ^ x2.rotrBH(r2, o4, 34) ^ x2.rotrBH(r2, o4, 39), st = x2.rotrSL(r2, o4, 28) ^ x2.rotrBL(r2, o4, 34) ^ x2.rotrBL(r2, o4, 39), at = r2 & s2 ^ r2 & u ^ s2 & u, Ct = o4 & a ^ o4 & i2 ^ a & i2;
      v3 = g3 | 0, L3 = S2 | 0, g3 = w3 | 0, S2 = h3 | 0, w3 = l4 | 0, h3 = p3 | 0, { h: l4, l: p3 } = x2.add(D2 | 0, c5 | 0, O4 | 0, ot | 0), D2 = u | 0, c5 = i2 | 0, u = s2 | 0, i2 = a | 0, s2 = r2 | 0, a = o4 | 0;
      const At = x2.add3L(ot, st, Ct);
      r2 = x2.add3H(At, O4, tt, at), o4 = At | 0;
    }
    ({ h: r2, l: o4 } = x2.add(this.Ah | 0, this.Al | 0, r2 | 0, o4 | 0)), { h: s2, l: a } = x2.add(this.Bh | 0, this.Bl | 0, s2 | 0, a | 0), { h: u, l: i2 } = x2.add(this.Ch | 0, this.Cl | 0, u | 0, i2 | 0), { h: D2, l: c5 } = x2.add(this.Dh | 0, this.Dl | 0, D2 | 0, c5 | 0), { h: l4, l: p3 } = x2.add(this.Eh | 0, this.El | 0, l4 | 0, p3 | 0), { h: w3, l: h3 } = x2.add(this.Fh | 0, this.Fl | 0, w3 | 0, h3 | 0), { h: g3, l: S2 } = x2.add(this.Gh | 0, this.Gl | 0, g3 | 0, S2 | 0), { h: v3, l: L3 } = x2.add(this.Hh | 0, this.Hl | 0, v3 | 0, L3 | 0), this.set(r2, o4, s2, a, u, i2, D2, c5, l4, p3, w3, h3, g3, S2, v3, L3);
  }
  roundClean() {
    P.fill(0), Q.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var Kn = Bn(() => new Jn());
var vt = BigInt(0);
var be = BigInt(1);
var Wn = BigInt(2);
function It(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function Ut(t) {
  if (!It(t)) throw new Error("Uint8Array expected");
}
function Tt(t, e2) {
  if (typeof e2 != "boolean") throw new Error(t + " boolean expected, got " + e2);
}
var Xn = Array.from({ length: 256 }, (t, e2) => e2.toString(16).padStart(2, "0"));
function Ft(t) {
  Ut(t);
  let e2 = "";
  for (let n3 = 0; n3 < t.length; n3++) e2 += Xn[t[n3]];
  return e2;
}
function pe(t) {
  if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
  return t === "" ? vt : BigInt("0x" + t);
}
var K = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function we(t) {
  if (t >= K._0 && t <= K._9) return t - K._0;
  if (t >= K.A && t <= K.F) return t - (K.A - 10);
  if (t >= K.a && t <= K.f) return t - (K.a - 10);
}
function Ee(t) {
  if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
  const e2 = t.length, n3 = e2 / 2;
  if (e2 % 2) throw new Error("hex string expected, got unpadded hex of length " + e2);
  const r2 = new Uint8Array(n3);
  for (let o4 = 0, s2 = 0; o4 < n3; o4++, s2 += 2) {
    const a = we(t.charCodeAt(s2)), u = we(t.charCodeAt(s2 + 1));
    if (a === void 0 || u === void 0) {
      const i2 = t[s2] + t[s2 + 1];
      throw new Error('hex string expected, got non-hex character "' + i2 + '" at index ' + s2);
    }
    r2[o4] = a * 16 + u;
  }
  return r2;
}
function Pn(t) {
  return pe(Ft(t));
}
function Et(t) {
  return Ut(t), pe(Ft(Uint8Array.from(t).reverse()));
}
function ge(t, e2) {
  return Ee(t.toString(16).padStart(e2 * 2, "0"));
}
function Nt(t, e2) {
  return ge(t, e2).reverse();
}
function W(t, e2, n3) {
  let r2;
  if (typeof e2 == "string") try {
    r2 = Ee(e2);
  } catch (s2) {
    throw new Error(t + " must be hex string or Uint8Array, cause: " + s2);
  }
  else if (It(e2)) r2 = Uint8Array.from(e2);
  else throw new Error(t + " must be hex string or Uint8Array");
  const o4 = r2.length;
  if (typeof n3 == "number" && o4 !== n3) throw new Error(t + " of length " + n3 + " expected, got " + o4);
  return r2;
}
function ye(...t) {
  let e2 = 0;
  for (let r2 = 0; r2 < t.length; r2++) {
    const o4 = t[r2];
    Ut(o4), e2 += o4.length;
  }
  const n3 = new Uint8Array(e2);
  for (let r2 = 0, o4 = 0; r2 < t.length; r2++) {
    const s2 = t[r2];
    n3.set(s2, o4), o4 += s2.length;
  }
  return n3;
}
var Lt = (t) => typeof t == "bigint" && vt <= t;
function Qn(t, e2, n3) {
  return Lt(t) && Lt(e2) && Lt(n3) && e2 <= t && t < n3;
}
function ft(t, e2, n3, r2) {
  if (!Qn(e2, n3, r2)) throw new Error("expected valid " + t + ": " + n3 + " <= n < " + r2 + ", got " + e2);
}
function tr(t) {
  let e2;
  for (e2 = 0; t > vt; t >>= be, e2 += 1) ;
  return e2;
}
var er = (t) => (Wn << BigInt(t - 1)) - be;
var nr = { bigint: (t) => typeof t == "bigint", function: (t) => typeof t == "function", boolean: (t) => typeof t == "boolean", string: (t) => typeof t == "string", stringOrUint8Array: (t) => typeof t == "string" || It(t), isSafeInteger: (t) => Number.isSafeInteger(t), array: (t) => Array.isArray(t), field: (t, e2) => e2.Fp.isValid(t), hash: (t) => typeof t == "function" && Number.isSafeInteger(t.outputLen) };
function Ot(t, e2, n3 = {}) {
  const r2 = (o4, s2, a) => {
    const u = nr[s2];
    if (typeof u != "function") throw new Error("invalid validator function");
    const i2 = t[o4];
    if (!(a && i2 === void 0) && !u(i2, t)) throw new Error("param " + String(o4) + " is invalid. Expected " + s2 + ", got " + i2);
  };
  for (const [o4, s2] of Object.entries(e2)) r2(o4, s2, false);
  for (const [o4, s2] of Object.entries(n3)) r2(o4, s2, true);
  return t;
}
function xe(t) {
  const e2 = /* @__PURE__ */ new WeakMap();
  return (n3, ...r2) => {
    const o4 = e2.get(n3);
    if (o4 !== void 0) return o4;
    const s2 = t(n3, ...r2);
    return e2.set(n3, s2), s2;
  };
}
var M = BigInt(0);
var N = BigInt(1);
var nt = BigInt(2);
var rr = BigInt(3);
var Ht = BigInt(4);
var Be = BigInt(5);
var Ce = BigInt(8);
function H(t, e2) {
  const n3 = t % e2;
  return n3 >= M ? n3 : e2 + n3;
}
function or(t, e2, n3) {
  if (e2 < M) throw new Error("invalid exponent, negatives unsupported");
  if (n3 <= M) throw new Error("invalid modulus");
  if (n3 === N) return M;
  let r2 = N;
  for (; e2 > M; ) e2 & N && (r2 = r2 * t % n3), t = t * t % n3, e2 >>= N;
  return r2;
}
function J(t, e2, n3) {
  let r2 = t;
  for (; e2-- > M; ) r2 *= r2, r2 %= n3;
  return r2;
}
function Ae(t, e2) {
  if (t === M) throw new Error("invert: expected non-zero number");
  if (e2 <= M) throw new Error("invert: expected positive modulus, got " + e2);
  let n3 = H(t, e2), r2 = e2, o4 = M, s2 = N;
  for (; n3 !== M; ) {
    const u = r2 / n3, i2 = r2 % n3, D2 = o4 - s2 * u;
    r2 = n3, n3 = i2, o4 = s2, s2 = D2;
  }
  if (r2 !== N) throw new Error("invert: does not exist");
  return H(o4, e2);
}
function sr(t) {
  const e2 = (t - N) / nt;
  let n3, r2, o4;
  for (n3 = t - N, r2 = 0; n3 % nt === M; n3 /= nt, r2++) ;
  for (o4 = nt; o4 < t && or(o4, e2, t) !== t - N; o4++) if (o4 > 1e3) throw new Error("Cannot find square root: likely non-prime P");
  if (r2 === 1) {
    const a = (t + N) / Ht;
    return function(i2, D2) {
      const c5 = i2.pow(D2, a);
      if (!i2.eql(i2.sqr(c5), D2)) throw new Error("Cannot find square root");
      return c5;
    };
  }
  const s2 = (n3 + N) / nt;
  return function(u, i2) {
    if (u.pow(i2, e2) === u.neg(u.ONE)) throw new Error("Cannot find square root");
    let D2 = r2, c5 = u.pow(u.mul(u.ONE, o4), n3), l4 = u.pow(i2, s2), p3 = u.pow(i2, n3);
    for (; !u.eql(p3, u.ONE); ) {
      if (u.eql(p3, u.ZERO)) return u.ZERO;
      let w3 = 1;
      for (let g3 = u.sqr(p3); w3 < D2 && !u.eql(g3, u.ONE); w3++) g3 = u.sqr(g3);
      const h3 = u.pow(c5, N << BigInt(D2 - w3 - 1));
      c5 = u.sqr(h3), l4 = u.mul(l4, h3), p3 = u.mul(p3, c5), D2 = w3;
    }
    return l4;
  };
}
function ir(t) {
  if (t % Ht === rr) {
    const e2 = (t + N) / Ht;
    return function(r2, o4) {
      const s2 = r2.pow(o4, e2);
      if (!r2.eql(r2.sqr(s2), o4)) throw new Error("Cannot find square root");
      return s2;
    };
  }
  if (t % Ce === Be) {
    const e2 = (t - Be) / Ce;
    return function(r2, o4) {
      const s2 = r2.mul(o4, nt), a = r2.pow(s2, e2), u = r2.mul(o4, a), i2 = r2.mul(r2.mul(u, nt), a), D2 = r2.mul(u, r2.sub(i2, r2.ONE));
      if (!r2.eql(r2.sqr(D2), o4)) throw new Error("Cannot find square root");
      return D2;
    };
  }
  return sr(t);
}
var ur = (t, e2) => (H(t, e2) & N) === N;
var cr = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function ar(t) {
  const e2 = { ORDER: "bigint", MASK: "bigint", BYTES: "isSafeInteger", BITS: "isSafeInteger" }, n3 = cr.reduce((r2, o4) => (r2[o4] = "function", r2), e2);
  return Ot(t, n3);
}
function fr(t, e2, n3) {
  if (n3 < M) throw new Error("invalid exponent, negatives unsupported");
  if (n3 === M) return t.ONE;
  if (n3 === N) return e2;
  let r2 = t.ONE, o4 = e2;
  for (; n3 > M; ) n3 & N && (r2 = t.mul(r2, o4)), o4 = t.sqr(o4), n3 >>= N;
  return r2;
}
function Dr(t, e2) {
  const n3 = new Array(e2.length), r2 = e2.reduce((s2, a, u) => t.is0(a) ? s2 : (n3[u] = s2, t.mul(s2, a)), t.ONE), o4 = t.inv(r2);
  return e2.reduceRight((s2, a, u) => t.is0(a) ? s2 : (n3[u] = t.mul(s2, n3[u]), t.mul(s2, a)), o4), n3;
}
function me(t, e2) {
  const n3 = e2 !== void 0 ? e2 : t.toString(2).length, r2 = Math.ceil(n3 / 8);
  return { nBitLength: n3, nByteLength: r2 };
}
function _e(t, e2, n3 = false, r2 = {}) {
  if (t <= M) throw new Error("invalid field: expected ORDER > 0, got " + t);
  const { nBitLength: o4, nByteLength: s2 } = me(t, e2);
  if (s2 > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let a;
  const u = Object.freeze({ ORDER: t, isLE: n3, BITS: o4, BYTES: s2, MASK: er(o4), ZERO: M, ONE: N, create: (i2) => H(i2, t), isValid: (i2) => {
    if (typeof i2 != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof i2);
    return M <= i2 && i2 < t;
  }, is0: (i2) => i2 === M, isOdd: (i2) => (i2 & N) === N, neg: (i2) => H(-i2, t), eql: (i2, D2) => i2 === D2, sqr: (i2) => H(i2 * i2, t), add: (i2, D2) => H(i2 + D2, t), sub: (i2, D2) => H(i2 - D2, t), mul: (i2, D2) => H(i2 * D2, t), pow: (i2, D2) => fr(u, i2, D2), div: (i2, D2) => H(i2 * Ae(D2, t), t), sqrN: (i2) => i2 * i2, addN: (i2, D2) => i2 + D2, subN: (i2, D2) => i2 - D2, mulN: (i2, D2) => i2 * D2, inv: (i2) => Ae(i2, t), sqrt: r2.sqrt || ((i2) => (a || (a = ir(t)), a(u, i2))), invertBatch: (i2) => Dr(u, i2), cmov: (i2, D2, c5) => c5 ? D2 : i2, toBytes: (i2) => n3 ? Nt(i2, s2) : ge(i2, s2), fromBytes: (i2) => {
    if (i2.length !== s2) throw new Error("Field.fromBytes: expected " + s2 + " bytes, got " + i2.length);
    return n3 ? Et(i2) : Pn(i2);
  } });
  return Object.freeze(u);
}
var Se = BigInt(0);
var gt = BigInt(1);
function zt(t, e2) {
  const n3 = e2.negate();
  return t ? n3 : e2;
}
function ve(t, e2) {
  if (!Number.isSafeInteger(t) || t <= 0 || t > e2) throw new Error("invalid window size, expected [1.." + e2 + "], got W=" + t);
}
function Mt(t, e2) {
  ve(t, e2);
  const n3 = Math.ceil(e2 / t) + 1, r2 = 2 ** (t - 1);
  return { windows: n3, windowSize: r2 };
}
function dr(t, e2) {
  if (!Array.isArray(t)) throw new Error("array expected");
  t.forEach((n3, r2) => {
    if (!(n3 instanceof e2)) throw new Error("invalid point at index " + r2);
  });
}
function hr(t, e2) {
  if (!Array.isArray(t)) throw new Error("array of scalars expected");
  t.forEach((n3, r2) => {
    if (!e2.isValid(n3)) throw new Error("invalid scalar at index " + r2);
  });
}
var qt = /* @__PURE__ */ new WeakMap();
var Ie = /* @__PURE__ */ new WeakMap();
function $t(t) {
  return Ie.get(t) || 1;
}
function lr(t, e2) {
  return { constTimeNegate: zt, hasPrecomputes(n3) {
    return $t(n3) !== 1;
  }, unsafeLadder(n3, r2, o4 = t.ZERO) {
    let s2 = n3;
    for (; r2 > Se; ) r2 & gt && (o4 = o4.add(s2)), s2 = s2.double(), r2 >>= gt;
    return o4;
  }, precomputeWindow(n3, r2) {
    const { windows: o4, windowSize: s2 } = Mt(r2, e2), a = [];
    let u = n3, i2 = u;
    for (let D2 = 0; D2 < o4; D2++) {
      i2 = u, a.push(i2);
      for (let c5 = 1; c5 < s2; c5++) i2 = i2.add(u), a.push(i2);
      u = i2.double();
    }
    return a;
  }, wNAF(n3, r2, o4) {
    const { windows: s2, windowSize: a } = Mt(n3, e2);
    let u = t.ZERO, i2 = t.BASE;
    const D2 = BigInt(2 ** n3 - 1), c5 = 2 ** n3, l4 = BigInt(n3);
    for (let p3 = 0; p3 < s2; p3++) {
      const w3 = p3 * a;
      let h3 = Number(o4 & D2);
      o4 >>= l4, h3 > a && (h3 -= c5, o4 += gt);
      const g3 = w3, S2 = w3 + Math.abs(h3) - 1, v3 = p3 % 2 !== 0, L3 = h3 < 0;
      h3 === 0 ? i2 = i2.add(zt(v3, r2[g3])) : u = u.add(zt(L3, r2[S2]));
    }
    return { p: u, f: i2 };
  }, wNAFUnsafe(n3, r2, o4, s2 = t.ZERO) {
    const { windows: a, windowSize: u } = Mt(n3, e2), i2 = BigInt(2 ** n3 - 1), D2 = 2 ** n3, c5 = BigInt(n3);
    for (let l4 = 0; l4 < a; l4++) {
      const p3 = l4 * u;
      if (o4 === Se) break;
      let w3 = Number(o4 & i2);
      if (o4 >>= c5, w3 > u && (w3 -= D2, o4 += gt), w3 === 0) continue;
      let h3 = r2[p3 + Math.abs(w3) - 1];
      w3 < 0 && (h3 = h3.negate()), s2 = s2.add(h3);
    }
    return s2;
  }, getPrecomputes(n3, r2, o4) {
    let s2 = qt.get(r2);
    return s2 || (s2 = this.precomputeWindow(r2, n3), n3 !== 1 && qt.set(r2, o4(s2))), s2;
  }, wNAFCached(n3, r2, o4) {
    const s2 = $t(n3);
    return this.wNAF(s2, this.getPrecomputes(s2, n3, o4), r2);
  }, wNAFCachedUnsafe(n3, r2, o4, s2) {
    const a = $t(n3);
    return a === 1 ? this.unsafeLadder(n3, r2, s2) : this.wNAFUnsafe(a, this.getPrecomputes(a, n3, o4), r2, s2);
  }, setWindowSize(n3, r2) {
    ve(r2, e2), Ie.set(n3, r2), qt.delete(n3);
  } };
}
function br(t, e2, n3, r2) {
  if (dr(n3, t), hr(r2, e2), n3.length !== r2.length) throw new Error("arrays of points and scalars must have equal length");
  const o4 = t.ZERO, s2 = tr(BigInt(n3.length)), a = s2 > 12 ? s2 - 3 : s2 > 4 ? s2 - 2 : s2 ? 2 : 1, u = (1 << a) - 1, i2 = new Array(u + 1).fill(o4), D2 = Math.floor((e2.BITS - 1) / a) * a;
  let c5 = o4;
  for (let l4 = D2; l4 >= 0; l4 -= a) {
    i2.fill(o4);
    for (let w3 = 0; w3 < r2.length; w3++) {
      const h3 = r2[w3], g3 = Number(h3 >> BigInt(l4) & BigInt(u));
      i2[g3] = i2[g3].add(n3[w3]);
    }
    let p3 = o4;
    for (let w3 = i2.length - 1, h3 = o4; w3 > 0; w3--) h3 = h3.add(i2[w3]), p3 = p3.add(h3);
    if (c5 = c5.add(p3), l4 !== 0) for (let w3 = 0; w3 < a; w3++) c5 = c5.double();
  }
  return c5;
}
function pr(t) {
  return ar(t.Fp), Ot(t, { n: "bigint", h: "bigint", Gx: "field", Gy: "field" }, { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }), Object.freeze({ ...me(t.n, t.nBitLength), ...t, p: t.Fp.ORDER });
}
var G = BigInt(0);
var j = BigInt(1);
var yt = BigInt(2);
var wr = BigInt(8);
var Er = { zip215: true };
function gr(t) {
  const e2 = pr(t);
  return Ot(t, { hash: "function", a: "bigint", d: "bigint", randomBytes: "function" }, { adjustScalarBytes: "function", domain: "function", uvRatio: "function", mapToCurve: "function" }), Object.freeze({ ...e2 });
}
function yr(t) {
  const e2 = gr(t), { Fp: n3, n: r2, prehash: o4, hash: s2, randomBytes: a, nByteLength: u, h: i2 } = e2, D2 = yt << BigInt(u * 8) - j, c5 = n3.create, l4 = _e(e2.n, e2.nBitLength), p3 = e2.uvRatio || ((y3, f3) => {
    try {
      return { isValid: true, value: n3.sqrt(y3 * n3.inv(f3)) };
    } catch {
      return { isValid: false, value: G };
    }
  }), w3 = e2.adjustScalarBytes || ((y3) => y3), h3 = e2.domain || ((y3, f3, b2) => {
    if (Tt("phflag", b2), f3.length || b2) throw new Error("Contexts/pre-hash are not supported");
    return y3;
  });
  function g3(y3, f3) {
    ft("coordinate " + y3, f3, G, D2);
  }
  function S2(y3) {
    if (!(y3 instanceof d3)) throw new Error("ExtendedPoint expected");
  }
  const v3 = xe((y3, f3) => {
    const { ex: b2, ey: E4, ez: B2 } = y3, C2 = y3.is0();
    f3 == null && (f3 = C2 ? wr : n3.inv(B2));
    const A2 = c5(b2 * f3), U2 = c5(E4 * f3), _3 = c5(B2 * f3);
    if (C2) return { x: G, y: j };
    if (_3 !== j) throw new Error("invZ was invalid");
    return { x: A2, y: U2 };
  }), L3 = xe((y3) => {
    const { a: f3, d: b2 } = e2;
    if (y3.is0()) throw new Error("bad point: ZERO");
    const { ex: E4, ey: B2, ez: C2, et: A2 } = y3, U2 = c5(E4 * E4), _3 = c5(B2 * B2), T3 = c5(C2 * C2), $ = c5(T3 * T3), R = c5(U2 * f3), V = c5(T3 * c5(R + _3)), Y = c5($ + c5(b2 * c5(U2 * _3)));
    if (V !== Y) throw new Error("bad point: equation left != right (1)");
    const Z = c5(E4 * B2), X = c5(C2 * A2);
    if (Z !== X) throw new Error("bad point: equation left != right (2)");
    return true;
  });
  class d3 {
    constructor(f3, b2, E4, B2) {
      this.ex = f3, this.ey = b2, this.ez = E4, this.et = B2, g3("x", f3), g3("y", b2), g3("z", E4), g3("t", B2), Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(f3) {
      if (f3 instanceof d3) throw new Error("extended point not allowed");
      const { x: b2, y: E4 } = f3 || {};
      return g3("x", b2), g3("y", E4), new d3(b2, E4, j, c5(b2 * E4));
    }
    static normalizeZ(f3) {
      const b2 = n3.invertBatch(f3.map((E4) => E4.ez));
      return f3.map((E4, B2) => E4.toAffine(b2[B2])).map(d3.fromAffine);
    }
    static msm(f3, b2) {
      return br(d3, l4, f3, b2);
    }
    _setWindowSize(f3) {
      q.setWindowSize(this, f3);
    }
    assertValidity() {
      L3(this);
    }
    equals(f3) {
      S2(f3);
      const { ex: b2, ey: E4, ez: B2 } = this, { ex: C2, ey: A2, ez: U2 } = f3, _3 = c5(b2 * U2), T3 = c5(C2 * B2), $ = c5(E4 * U2), R = c5(A2 * B2);
      return _3 === T3 && $ === R;
    }
    is0() {
      return this.equals(d3.ZERO);
    }
    negate() {
      return new d3(c5(-this.ex), this.ey, this.ez, c5(-this.et));
    }
    double() {
      const { a: f3 } = e2, { ex: b2, ey: E4, ez: B2 } = this, C2 = c5(b2 * b2), A2 = c5(E4 * E4), U2 = c5(yt * c5(B2 * B2)), _3 = c5(f3 * C2), T3 = b2 + E4, $ = c5(c5(T3 * T3) - C2 - A2), R = _3 + A2, V = R - U2, Y = _3 - A2, Z = c5($ * V), X = c5(R * Y), et = c5($ * Y), pt = c5(V * R);
      return new d3(Z, X, pt, et);
    }
    add(f3) {
      S2(f3);
      const { a: b2, d: E4 } = e2, { ex: B2, ey: C2, ez: A2, et: U2 } = this, { ex: _3, ey: T3, ez: $, et: R } = f3;
      if (b2 === BigInt(-1)) {
        const re = c5((C2 - B2) * (T3 + _3)), oe = c5((C2 + B2) * (T3 - _3)), mt = c5(oe - re);
        if (mt === G) return this.double();
        const se = c5(A2 * yt * R), ie = c5(U2 * yt * $), ue = ie + se, ce = oe + re, ae = ie - se, Dn = c5(ue * mt), dn = c5(ce * ae), hn = c5(ue * ae), ln = c5(mt * ce);
        return new d3(Dn, dn, ln, hn);
      }
      const V = c5(B2 * _3), Y = c5(C2 * T3), Z = c5(U2 * E4 * R), X = c5(A2 * $), et = c5((B2 + C2) * (_3 + T3) - V - Y), pt = X - Z, ee = X + Z, ne = c5(Y - b2 * V), un = c5(et * pt), cn = c5(ee * ne), an = c5(et * ne), fn = c5(pt * ee);
      return new d3(un, cn, fn, an);
    }
    subtract(f3) {
      return this.add(f3.negate());
    }
    wNAF(f3) {
      return q.wNAFCached(this, f3, d3.normalizeZ);
    }
    multiply(f3) {
      const b2 = f3;
      ft("scalar", b2, j, r2);
      const { p: E4, f: B2 } = this.wNAF(b2);
      return d3.normalizeZ([E4, B2])[0];
    }
    multiplyUnsafe(f3, b2 = d3.ZERO) {
      const E4 = f3;
      return ft("scalar", E4, G, r2), E4 === G ? F : this.is0() || E4 === j ? this : q.wNAFCachedUnsafe(this, E4, d3.normalizeZ, b2);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(i2).is0();
    }
    isTorsionFree() {
      return q.unsafeLadder(this, r2).is0();
    }
    toAffine(f3) {
      return v3(this, f3);
    }
    clearCofactor() {
      const { h: f3 } = e2;
      return f3 === j ? this : this.multiplyUnsafe(f3);
    }
    static fromHex(f3, b2 = false) {
      const { d: E4, a: B2 } = e2, C2 = n3.BYTES;
      f3 = W("pointHex", f3, C2), Tt("zip215", b2);
      const A2 = f3.slice(), U2 = f3[C2 - 1];
      A2[C2 - 1] = U2 & -129;
      const _3 = Et(A2), T3 = b2 ? D2 : n3.ORDER;
      ft("pointHex.y", _3, G, T3);
      const $ = c5(_3 * _3), R = c5($ - j), V = c5(E4 * $ - B2);
      let { isValid: Y, value: Z } = p3(R, V);
      if (!Y) throw new Error("Point.fromHex: invalid y coordinate");
      const X = (Z & j) === j, et = (U2 & 128) !== 0;
      if (!b2 && Z === G && et) throw new Error("Point.fromHex: x=0 and x_0=1");
      return et !== X && (Z = c5(-Z)), d3.fromAffine({ x: Z, y: _3 });
    }
    static fromPrivateKey(f3) {
      return O4(f3).point;
    }
    toRawBytes() {
      const { x: f3, y: b2 } = this.toAffine(), E4 = Nt(b2, n3.BYTES);
      return E4[E4.length - 1] |= f3 & j ? 128 : 0, E4;
    }
    toHex() {
      return Ft(this.toRawBytes());
    }
  }
  d3.BASE = new d3(e2.Gx, e2.Gy, j, c5(e2.Gx * e2.Gy)), d3.ZERO = new d3(G, j, j, G);
  const { BASE: m3, ZERO: F } = d3, q = lr(d3, u * 8);
  function z3(y3) {
    return H(y3, r2);
  }
  function I2(y3) {
    return z3(Et(y3));
  }
  function O4(y3) {
    const f3 = n3.BYTES;
    y3 = W("private key", y3, f3);
    const b2 = W("hashed private key", s2(y3), 2 * f3), E4 = w3(b2.slice(0, f3)), B2 = b2.slice(f3, 2 * f3), C2 = I2(E4), A2 = m3.multiply(C2), U2 = A2.toRawBytes();
    return { head: E4, prefix: B2, scalar: C2, point: A2, pointBytes: U2 };
  }
  function ot(y3) {
    return O4(y3).pointBytes;
  }
  function tt(y3 = new Uint8Array(), ...f3) {
    const b2 = ye(...f3);
    return I2(s2(h3(b2, W("context", y3), !!o4)));
  }
  function st(y3, f3, b2 = {}) {
    y3 = W("message", y3), o4 && (y3 = o4(y3));
    const { prefix: E4, scalar: B2, pointBytes: C2 } = O4(f3), A2 = tt(b2.context, E4, y3), U2 = m3.multiply(A2).toRawBytes(), _3 = tt(b2.context, U2, C2, y3), T3 = z3(A2 + _3 * B2);
    ft("signature.s", T3, G, r2);
    const $ = ye(U2, Nt(T3, n3.BYTES));
    return W("result", $, n3.BYTES * 2);
  }
  const at = Er;
  function Ct(y3, f3, b2, E4 = at) {
    const { context: B2, zip215: C2 } = E4, A2 = n3.BYTES;
    y3 = W("signature", y3, 2 * A2), f3 = W("message", f3), b2 = W("publicKey", b2, A2), C2 !== void 0 && Tt("zip215", C2), o4 && (f3 = o4(f3));
    const U2 = Et(y3.slice(A2, 2 * A2));
    let _3, T3, $;
    try {
      _3 = d3.fromHex(b2, C2), T3 = d3.fromHex(y3.slice(0, A2), C2), $ = m3.multiplyUnsafe(U2);
    } catch {
      return false;
    }
    if (!C2 && _3.isSmallOrder()) return false;
    const R = tt(B2, T3.toRawBytes(), _3.toRawBytes(), f3);
    return T3.add(_3.multiplyUnsafe(R)).subtract($).clearCofactor().equals(d3.ZERO);
  }
  return m3._setWindowSize(8), { CURVE: e2, getPublicKey: ot, sign: st, verify: Ct, ExtendedPoint: d3, utils: { getExtendedPublicKey: O4, randomPrivateKey: () => a(n3.BYTES), precompute(y3 = 8, f3 = d3.BASE) {
    return f3._setWindowSize(y3), f3.multiply(BigInt(3)), f3;
  } } };
}
BigInt(0), BigInt(1);
var kt = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
var Ue = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
BigInt(0);
var xr = BigInt(1);
var Te = BigInt(2);
BigInt(3);
var Br = BigInt(5);
var Cr = BigInt(8);
function Ar(t) {
  const e2 = BigInt(10), n3 = BigInt(20), r2 = BigInt(40), o4 = BigInt(80), s2 = kt, u = t * t % s2 * t % s2, i2 = J(u, Te, s2) * u % s2, D2 = J(i2, xr, s2) * t % s2, c5 = J(D2, Br, s2) * D2 % s2, l4 = J(c5, e2, s2) * c5 % s2, p3 = J(l4, n3, s2) * l4 % s2, w3 = J(p3, r2, s2) * p3 % s2, h3 = J(w3, o4, s2) * w3 % s2, g3 = J(h3, o4, s2) * w3 % s2, S2 = J(g3, e2, s2) * c5 % s2;
  return { pow_p_5_8: J(S2, Te, s2) * t % s2, b2: u };
}
function mr(t) {
  return t[0] &= 248, t[31] &= 127, t[31] |= 64, t;
}
function _r(t, e2) {
  const n3 = kt, r2 = H(e2 * e2 * e2, n3), o4 = H(r2 * r2 * e2, n3), s2 = Ar(t * o4).pow_p_5_8;
  let a = H(t * r2 * s2, n3);
  const u = H(e2 * a * a, n3), i2 = a, D2 = H(a * Ue, n3), c5 = u === t, l4 = u === H(-t, n3), p3 = u === H(-t * Ue, n3);
  return c5 && (a = i2), (l4 || p3) && (a = D2), ur(a, n3) && (a = H(-a, n3)), { isValid: c5 || l4, value: a };
}
var Sr = (() => _e(kt, void 0, true))();
var vr = (() => ({ a: BigInt(-1), d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"), Fp: Sr, n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"), h: Cr, Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"), Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"), hash: Kn, randomBytes: he, adjustScalarBytes: mr, uvRatio: _r }))();
var Rt = (() => yr(vr))();
var jt = "EdDSA";
var Zt = "JWT";
var ut = ".";
var Dt = "base64url";
var Gt = "utf8";
var xt = "utf8";
var Vt = ":";
var Yt = "did";
var Jt = "key";
var dt = "base58btc";
var Kt = "z";
var Wt = "K36";
var Ne = 32;
function Xt(t) {
  return globalThis.Buffer != null ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : t;
}
function Le(t = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? Xt(globalThis.Buffer.allocUnsafe(t)) : new Uint8Array(t);
}
function Oe(t, e2) {
  e2 || (e2 = t.reduce((o4, s2) => o4 + s2.length, 0));
  const n3 = Le(e2);
  let r2 = 0;
  for (const o4 of t) n3.set(o4, r2), r2 += o4.length;
  return Xt(n3);
}
function Ir(t, e2) {
  if (t.length >= 255) throw new TypeError("Alphabet too long");
  for (var n3 = new Uint8Array(256), r2 = 0; r2 < n3.length; r2++) n3[r2] = 255;
  for (var o4 = 0; o4 < t.length; o4++) {
    var s2 = t.charAt(o4), a = s2.charCodeAt(0);
    if (n3[a] !== 255) throw new TypeError(s2 + " is ambiguous");
    n3[a] = o4;
  }
  var u = t.length, i2 = t.charAt(0), D2 = Math.log(u) / Math.log(256), c5 = Math.log(256) / Math.log(u);
  function l4(h3) {
    if (h3 instanceof Uint8Array || (ArrayBuffer.isView(h3) ? h3 = new Uint8Array(h3.buffer, h3.byteOffset, h3.byteLength) : Array.isArray(h3) && (h3 = Uint8Array.from(h3))), !(h3 instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (h3.length === 0) return "";
    for (var g3 = 0, S2 = 0, v3 = 0, L3 = h3.length; v3 !== L3 && h3[v3] === 0; ) v3++, g3++;
    for (var d3 = (L3 - v3) * c5 + 1 >>> 0, m3 = new Uint8Array(d3); v3 !== L3; ) {
      for (var F = h3[v3], q = 0, z3 = d3 - 1; (F !== 0 || q < S2) && z3 !== -1; z3--, q++) F += 256 * m3[z3] >>> 0, m3[z3] = F % u >>> 0, F = F / u >>> 0;
      if (F !== 0) throw new Error("Non-zero carry");
      S2 = q, v3++;
    }
    for (var I2 = d3 - S2; I2 !== d3 && m3[I2] === 0; ) I2++;
    for (var O4 = i2.repeat(g3); I2 < d3; ++I2) O4 += t.charAt(m3[I2]);
    return O4;
  }
  function p3(h3) {
    if (typeof h3 != "string") throw new TypeError("Expected String");
    if (h3.length === 0) return new Uint8Array();
    var g3 = 0;
    if (h3[g3] !== " ") {
      for (var S2 = 0, v3 = 0; h3[g3] === i2; ) S2++, g3++;
      for (var L3 = (h3.length - g3) * D2 + 1 >>> 0, d3 = new Uint8Array(L3); h3[g3]; ) {
        var m3 = n3[h3.charCodeAt(g3)];
        if (m3 === 255) return;
        for (var F = 0, q = L3 - 1; (m3 !== 0 || F < v3) && q !== -1; q--, F++) m3 += u * d3[q] >>> 0, d3[q] = m3 % 256 >>> 0, m3 = m3 / 256 >>> 0;
        if (m3 !== 0) throw new Error("Non-zero carry");
        v3 = F, g3++;
      }
      if (h3[g3] !== " ") {
        for (var z3 = L3 - v3; z3 !== L3 && d3[z3] === 0; ) z3++;
        for (var I2 = new Uint8Array(S2 + (L3 - z3)), O4 = S2; z3 !== L3; ) I2[O4++] = d3[z3++];
        return I2;
      }
    }
  }
  function w3(h3) {
    var g3 = p3(h3);
    if (g3) return g3;
    throw new Error(`Non-${e2} character`);
  }
  return { encode: l4, decodeUnsafe: p3, decode: w3 };
}
var Ur = Ir;
var Tr = Ur;
var He = (t) => {
  if (t instanceof Uint8Array && t.constructor.name === "Uint8Array") return t;
  if (t instanceof ArrayBuffer) return new Uint8Array(t);
  if (ArrayBuffer.isView(t)) return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var Fr = (t) => new TextEncoder().encode(t);
var Nr = (t) => new TextDecoder().decode(t);
var Lr = class {
  constructor(e2, n3, r2) {
    this.name = e2, this.prefix = n3, this.baseEncode = r2;
  }
  encode(e2) {
    if (e2 instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e2)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var Or = class {
  constructor(e2, n3, r2) {
    if (this.name = e2, this.prefix = n3, n3.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = n3.codePointAt(0), this.baseDecode = r2;
  }
  decode(e2) {
    if (typeof e2 == "string") {
      if (e2.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e2)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e2.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e2) {
    return ze(this, e2);
  }
};
var Hr = class {
  constructor(e2) {
    this.decoders = e2;
  }
  or(e2) {
    return ze(this, e2);
  }
  decode(e2) {
    const n3 = e2[0], r2 = this.decoders[n3];
    if (r2) return r2.decode(e2);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e2)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var ze = (t, e2) => new Hr({ ...t.decoders || { [t.prefix]: t }, ...e2.decoders || { [e2.prefix]: e2 } });
var zr = class {
  constructor(e2, n3, r2, o4) {
    this.name = e2, this.prefix = n3, this.baseEncode = r2, this.baseDecode = o4, this.encoder = new Lr(e2, n3, r2), this.decoder = new Or(e2, n3, o4);
  }
  encode(e2) {
    return this.encoder.encode(e2);
  }
  decode(e2) {
    return this.decoder.decode(e2);
  }
};
var Bt = ({ name: t, prefix: e2, encode: n3, decode: r2 }) => new zr(t, e2, n3, r2);
var ht = ({ prefix: t, name: e2, alphabet: n3 }) => {
  const { encode: r2, decode: o4 } = Tr(n3, e2);
  return Bt({ prefix: t, name: e2, encode: r2, decode: (s2) => He(o4(s2)) });
};
var Mr = (t, e2, n3, r2) => {
  const o4 = {};
  for (let c5 = 0; c5 < e2.length; ++c5) o4[e2[c5]] = c5;
  let s2 = t.length;
  for (; t[s2 - 1] === "="; ) --s2;
  const a = new Uint8Array(s2 * n3 / 8 | 0);
  let u = 0, i2 = 0, D2 = 0;
  for (let c5 = 0; c5 < s2; ++c5) {
    const l4 = o4[t[c5]];
    if (l4 === void 0) throw new SyntaxError(`Non-${r2} character`);
    i2 = i2 << n3 | l4, u += n3, u >= 8 && (u -= 8, a[D2++] = 255 & i2 >> u);
  }
  if (u >= n3 || 255 & i2 << 8 - u) throw new SyntaxError("Unexpected end of data");
  return a;
};
var qr = (t, e2, n3) => {
  const r2 = e2[e2.length - 1] === "=", o4 = (1 << n3) - 1;
  let s2 = "", a = 0, u = 0;
  for (let i2 = 0; i2 < t.length; ++i2) for (u = u << 8 | t[i2], a += 8; a > n3; ) a -= n3, s2 += e2[o4 & u >> a];
  if (a && (s2 += e2[o4 & u << n3 - a]), r2) for (; s2.length * n3 & 7; ) s2 += "=";
  return s2;
};
var k2 = ({ name: t, prefix: e2, bitsPerChar: n3, alphabet: r2 }) => Bt({ prefix: e2, name: t, encode(o4) {
  return qr(o4, r2, n3);
}, decode(o4) {
  return Mr(o4, r2, n3, t);
} });
var $r = Bt({ prefix: "\0", name: "identity", encode: (t) => Nr(t), decode: (t) => Fr(t) });
var kr = Object.freeze({ __proto__: null, identity: $r });
var Rr = k2({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var jr = Object.freeze({ __proto__: null, base2: Rr });
var Zr = k2({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var Gr = Object.freeze({ __proto__: null, base8: Zr });
var Vr = ht({ prefix: "9", name: "base10", alphabet: "0123456789" });
var Yr = Object.freeze({ __proto__: null, base10: Vr });
var Jr = k2({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var Kr = k2({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Wr = Object.freeze({ __proto__: null, base16: Jr, base16upper: Kr });
var Xr = k2({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var Pr = k2({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var Qr = k2({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var to = k2({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var eo = k2({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var no = k2({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var ro = k2({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var oo = k2({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var so = k2({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var io = Object.freeze({ __proto__: null, base32: Xr, base32upper: Pr, base32pad: Qr, base32padupper: to, base32hex: eo, base32hexupper: no, base32hexpad: ro, base32hexpadupper: oo, base32z: so });
var uo = ht({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var co = ht({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var ao = Object.freeze({ __proto__: null, base36: uo, base36upper: co });
var fo = ht({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Do = ht({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var ho = Object.freeze({ __proto__: null, base58btc: fo, base58flickr: Do });
var lo = k2({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var bo = k2({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var po = k2({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var wo = k2({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Eo = Object.freeze({ __proto__: null, base64: lo, base64pad: bo, base64url: po, base64urlpad: wo });
var Me = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂");
var go = Me.reduce((t, e2, n3) => (t[n3] = e2, t), []);
var yo = Me.reduce((t, e2, n3) => (t[e2.codePointAt(0)] = n3, t), []);
function xo(t) {
  return t.reduce((e2, n3) => (e2 += go[n3], e2), "");
}
function Bo(t) {
  const e2 = [];
  for (const n3 of t) {
    const r2 = yo[n3.codePointAt(0)];
    if (r2 === void 0) throw new Error(`Non-base256emoji character: ${n3}`);
    e2.push(r2);
  }
  return new Uint8Array(e2);
}
var Co = Bt({ prefix: "🚀", name: "base256emoji", encode: xo, decode: Bo });
var Ao = Object.freeze({ __proto__: null, base256emoji: Co });
var mo = $e;
var qe = 128;
var _o = 127;
var So = ~_o;
var vo = Math.pow(2, 31);
function $e(t, e2, n3) {
  e2 = e2 || [], n3 = n3 || 0;
  for (var r2 = n3; t >= vo; ) e2[n3++] = t & 255 | qe, t /= 128;
  for (; t & So; ) e2[n3++] = t & 255 | qe, t >>>= 7;
  return e2[n3] = t | 0, $e.bytes = n3 - r2 + 1, e2;
}
var Io = Pt;
var Uo = 128;
var ke = 127;
function Pt(t, r2) {
  var n3 = 0, r2 = r2 || 0, o4 = 0, s2 = r2, a, u = t.length;
  do {
    if (s2 >= u) throw Pt.bytes = 0, new RangeError("Could not decode varint");
    a = t[s2++], n3 += o4 < 28 ? (a & ke) << o4 : (a & ke) * Math.pow(2, o4), o4 += 7;
  } while (a >= Uo);
  return Pt.bytes = s2 - r2, n3;
}
var To = Math.pow(2, 7);
var Fo = Math.pow(2, 14);
var No = Math.pow(2, 21);
var Lo = Math.pow(2, 28);
var Oo = Math.pow(2, 35);
var Ho = Math.pow(2, 42);
var zo = Math.pow(2, 49);
var Mo = Math.pow(2, 56);
var qo = Math.pow(2, 63);
var $o = function(t) {
  return t < To ? 1 : t < Fo ? 2 : t < No ? 3 : t < Lo ? 4 : t < Oo ? 5 : t < Ho ? 6 : t < zo ? 7 : t < Mo ? 8 : t < qo ? 9 : 10;
};
var ko = { encode: mo, decode: Io, encodingLength: $o };
var Re = ko;
var je = (t, e2, n3 = 0) => (Re.encode(t, e2, n3), e2);
var Ze = (t) => Re.encodingLength(t);
var Qt = (t, e2) => {
  const n3 = e2.byteLength, r2 = Ze(t), o4 = r2 + Ze(n3), s2 = new Uint8Array(o4 + n3);
  return je(t, s2, 0), je(n3, s2, r2), s2.set(e2, o4), new Ro(t, n3, e2, s2);
};
var Ro = class {
  constructor(e2, n3, r2, o4) {
    this.code = e2, this.size = n3, this.digest = r2, this.bytes = o4;
  }
};
var Ge = ({ name: t, code: e2, encode: n3 }) => new jo(t, e2, n3);
var jo = class {
  constructor(e2, n3, r2) {
    this.name = e2, this.code = n3, this.encode = r2;
  }
  digest(e2) {
    if (e2 instanceof Uint8Array) {
      const n3 = this.encode(e2);
      return n3 instanceof Uint8Array ? Qt(this.code, n3) : n3.then((r2) => Qt(this.code, r2));
    } else throw Error("Unknown type, must be binary type");
  }
};
var Ve = (t) => async (e2) => new Uint8Array(await crypto.subtle.digest(t, e2));
var Zo = Ge({ name: "sha2-256", code: 18, encode: Ve("SHA-256") });
var Go = Ge({ name: "sha2-512", code: 19, encode: Ve("SHA-512") });
var Vo = Object.freeze({ __proto__: null, sha256: Zo, sha512: Go });
var Ye = 0;
var Yo = "identity";
var Je = He;
var Jo = (t) => Qt(Ye, Je(t));
var Ko = { code: Ye, name: Yo, encode: Je, digest: Jo };
var Wo = Object.freeze({ __proto__: null, identity: Ko });
new TextEncoder(), new TextDecoder();
var Ke = { ...kr, ...jr, ...Gr, ...Yr, ...Wr, ...io, ...ao, ...ho, ...Eo, ...Ao };
({ ...Vo, ...Wo });
function We(t, e2, n3, r2) {
  return { name: t, prefix: e2, encoder: { name: t, prefix: e2, encode: n3 }, decoder: { decode: r2 } };
}
var Xe = We("utf8", "u", (t) => "u" + new TextDecoder("utf8").decode(t), (t) => new TextEncoder().encode(t.substring(1)));
var te = We("ascii", "a", (t) => {
  let e2 = "a";
  for (let n3 = 0; n3 < t.length; n3++) e2 += String.fromCharCode(t[n3]);
  return e2;
}, (t) => {
  t = t.substring(1);
  const e2 = Le(t.length);
  for (let n3 = 0; n3 < t.length; n3++) e2[n3] = t.charCodeAt(n3);
  return e2;
});
var Pe = { utf8: Xe, "utf-8": Xe, hex: Ke.base16, latin1: te, ascii: te, binary: te, ...Ke };
function ct(t, e2 = "utf8") {
  const n3 = Pe[e2];
  if (!n3) throw new Error(`Unsupported encoding "${e2}"`);
  return (e2 === "utf8" || e2 === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(t.buffer, t.byteOffset, t.byteLength).toString("utf8") : n3.encoder.encode(t).substring(1);
}
function rt(t, e2 = "utf8") {
  const n3 = Pe[e2];
  if (!n3) throw new Error(`Unsupported encoding "${e2}"`);
  return (e2 === "utf8" || e2 === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? Xt(globalThis.Buffer.from(t, "utf-8")) : n3.decoder.decode(`${n3.prefix}${t}`);
}
function lt(t) {
  return safeJsonParse(ct(rt(t, Dt), Gt));
}
function bt(t) {
  return ct(rt(safeJsonStringify(t), Gt), Dt);
}
function Qe(t) {
  const e2 = rt(Wt, dt), n3 = Kt + ct(Oe([e2, t]), dt);
  return [Yt, Jt, n3].join(Vt);
}
function en(t) {
  return ct(t, Dt);
}
function nn(t) {
  return rt(t, Dt);
}
function rn(t) {
  return rt([bt(t.header), bt(t.payload)].join(ut), xt);
}
function on(t) {
  return [bt(t.header), bt(t.payload), en(t.signature)].join(ut);
}
function sn(t) {
  const e2 = t.split(ut), n3 = lt(e2[0]), r2 = lt(e2[1]), o4 = nn(e2[2]), s2 = rt(e2.slice(0, 2).join(ut), xt);
  return { header: n3, payload: r2, signature: o4, data: s2 };
}
function Po(t = he(Ne)) {
  const e2 = Rt.getPublicKey(t);
  return { secretKey: Oe([t, e2]), publicKey: e2 };
}
async function Qo(t, e2, n3, r2, o4 = (0, import_time.fromMiliseconds)(Date.now())) {
  const s2 = { alg: jt, typ: Zt }, a = Qe(r2.publicKey), u = o4 + n3, i2 = { iss: a, sub: t, aud: e2, iat: o4, exp: u }, D2 = rn({ header: s2, payload: i2 }), c5 = Rt.sign(D2, r2.secretKey.slice(0, 32));
  return on({ header: s2, payload: i2, signature: c5 });
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/constants.js
var PARSE_ERROR = "PARSE_ERROR";
var INVALID_REQUEST = "INVALID_REQUEST";
var METHOD_NOT_FOUND = "METHOD_NOT_FOUND";
var INVALID_PARAMS = "INVALID_PARAMS";
var INTERNAL_ERROR = "INTERNAL_ERROR";
var SERVER_ERROR = "SERVER_ERROR";
var RESERVED_ERROR_CODES = [-32700, -32600, -32601, -32602, -32603];
var SERVER_ERROR_CODE_RANGE = [-32e3, -32099];
var STANDARD_ERROR_MAP = {
  [PARSE_ERROR]: { code: -32700, message: "Parse error" },
  [INVALID_REQUEST]: { code: -32600, message: "Invalid Request" },
  [METHOD_NOT_FOUND]: { code: -32601, message: "Method not found" },
  [INVALID_PARAMS]: { code: -32602, message: "Invalid params" },
  [INTERNAL_ERROR]: { code: -32603, message: "Internal error" },
  [SERVER_ERROR]: { code: -32e3, message: "Server error" }
};
var DEFAULT_ERROR = SERVER_ERROR;

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/error.js
function isServerErrorCode(code) {
  return code <= SERVER_ERROR_CODE_RANGE[0] && code >= SERVER_ERROR_CODE_RANGE[1];
}
function isReservedErrorCode(code) {
  return RESERVED_ERROR_CODES.includes(code);
}
function isValidErrorCode(code) {
  return typeof code === "number";
}
function getError(type) {
  if (!Object.keys(STANDARD_ERROR_MAP).includes(type)) {
    return STANDARD_ERROR_MAP[DEFAULT_ERROR];
  }
  return STANDARD_ERROR_MAP[type];
}
function getErrorByCode(code) {
  const match = Object.values(STANDARD_ERROR_MAP).find((e2) => e2.code === code);
  if (!match) {
    return STANDARD_ERROR_MAP[DEFAULT_ERROR];
  }
  return match;
}
function validateJsonRpcError(response) {
  if (typeof response.error.code === "undefined") {
    return { valid: false, error: "Missing code for JSON-RPC error" };
  }
  if (typeof response.error.message === "undefined") {
    return { valid: false, error: "Missing message for JSON-RPC error" };
  }
  if (!isValidErrorCode(response.error.code)) {
    return {
      valid: false,
      error: `Invalid error code type for JSON-RPC: ${response.error.code}`
    };
  }
  if (isReservedErrorCode(response.error.code)) {
    const error = getErrorByCode(response.error.code);
    if (error.message !== STANDARD_ERROR_MAP[DEFAULT_ERROR].message && response.error.message === error.message) {
      return {
        valid: false,
        error: `Invalid error code message for JSON-RPC: ${response.error.code}`
      };
    }
  }
  return { valid: true };
}
function parseConnectionError(e2, url, type) {
  return e2.message.includes("getaddrinfo ENOTFOUND") || e2.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${type} RPC url at ${url}`) : e2;
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/format.js
function payloadId(entropy = 3) {
  const date = Date.now() * Math.pow(10, entropy);
  const extra = Math.floor(Math.random() * Math.pow(10, entropy));
  return date + extra;
}
function getBigIntRpcId(entropy = 6) {
  return BigInt(payloadId(entropy));
}
function formatJsonRpcRequest(method, params, id) {
  return {
    id: id || payloadId(),
    jsonrpc: "2.0",
    method,
    params
  };
}
function formatJsonRpcResult(id, result) {
  return {
    id,
    jsonrpc: "2.0",
    result
  };
}
function formatJsonRpcError(id, error, data) {
  return {
    id,
    jsonrpc: "2.0",
    error: formatErrorMessage(error, data)
  };
}
function formatErrorMessage(error, data) {
  if (typeof error === "undefined") {
    return getError(INTERNAL_ERROR);
  }
  if (typeof error === "string") {
    error = Object.assign(Object.assign({}, getError(SERVER_ERROR)), { message: error });
  }
  if (typeof data !== "undefined") {
    error.data = data;
  }
  if (isReservedErrorCode(error.code)) {
    error = getErrorByCode(error.code);
  }
  return error;
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  DEFAULT_ERROR: () => DEFAULT_ERROR,
  IBaseJsonRpcProvider: () => n2,
  IEvents: () => e,
  IJsonRpcConnection: () => o,
  IJsonRpcProvider: () => r,
  INTERNAL_ERROR: () => INTERNAL_ERROR,
  INVALID_PARAMS: () => INVALID_PARAMS,
  INVALID_REQUEST: () => INVALID_REQUEST,
  METHOD_NOT_FOUND: () => METHOD_NOT_FOUND,
  PARSE_ERROR: () => PARSE_ERROR,
  RESERVED_ERROR_CODES: () => RESERVED_ERROR_CODES,
  SERVER_ERROR: () => SERVER_ERROR,
  SERVER_ERROR_CODE_RANGE: () => SERVER_ERROR_CODE_RANGE,
  STANDARD_ERROR_MAP: () => STANDARD_ERROR_MAP,
  formatErrorMessage: () => formatErrorMessage,
  formatJsonRpcError: () => formatJsonRpcError,
  formatJsonRpcRequest: () => formatJsonRpcRequest,
  formatJsonRpcResult: () => formatJsonRpcResult,
  getBigIntRpcId: () => getBigIntRpcId,
  getError: () => getError,
  getErrorByCode: () => getErrorByCode,
  isHttpUrl: () => isHttpUrl,
  isJsonRpcError: () => isJsonRpcError,
  isJsonRpcPayload: () => isJsonRpcPayload,
  isJsonRpcRequest: () => isJsonRpcRequest,
  isJsonRpcResponse: () => isJsonRpcResponse,
  isJsonRpcResult: () => isJsonRpcResult,
  isJsonRpcValidationInvalid: () => isJsonRpcValidationInvalid,
  isLocalhostUrl: () => isLocalhostUrl,
  isNodeJs: () => isNodeJs,
  isReservedErrorCode: () => isReservedErrorCode,
  isServerErrorCode: () => isServerErrorCode,
  isValidDefaultRoute: () => isValidDefaultRoute,
  isValidErrorCode: () => isValidErrorCode,
  isValidLeadingWildcardRoute: () => isValidLeadingWildcardRoute,
  isValidRoute: () => isValidRoute,
  isValidTrailingWildcardRoute: () => isValidTrailingWildcardRoute,
  isValidWildcardRoute: () => isValidWildcardRoute,
  isWsUrl: () => isWsUrl,
  parseConnectionError: () => parseConnectionError,
  payloadId: () => payloadId,
  validateJsonRpcError: () => validateJsonRpcError
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/env.js
var env_exports = {};
__export(env_exports, {
  isNodeJs: () => isNodeJs
});
var import_environment = __toESM(require_cjs2());
__reExport(env_exports, __toESM(require_cjs2()));
var isNodeJs = import_environment.isNode;

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
__reExport(esm_exports, env_exports);

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/routing.js
function isValidRoute(route) {
  if (route.includes("*")) {
    return isValidWildcardRoute(route);
  }
  if (/\W/g.test(route)) {
    return false;
  }
  return true;
}
function isValidDefaultRoute(route) {
  return route === "*";
}
function isValidWildcardRoute(route) {
  if (isValidDefaultRoute(route)) {
    return true;
  }
  if (!route.includes("*")) {
    return false;
  }
  if (route.split("*").length !== 2) {
    return false;
  }
  if (route.split("*").filter((x4) => x4.trim() === "").length !== 1) {
    return false;
  }
  return true;
}
function isValidLeadingWildcardRoute(route) {
  return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[0].trim();
}
function isValidTrailingWildcardRoute(route) {
  return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[1].trim();
}

// node_modules/@walletconnect/jsonrpc-types/dist/index.es.js
var e = class {
};
var o = class extends e {
  constructor(c5) {
    super();
  }
};
var n2 = class extends e {
  constructor() {
    super();
  }
};
var r = class extends n2 {
  constructor(c5) {
    super();
  }
};

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/url.js
var HTTP_REGEX = "^https?:";
var WS_REGEX = "^wss?:";
function getUrlProtocol(url) {
  const matches = url.match(new RegExp(/^\w+:/, "gi"));
  if (!matches || !matches.length)
    return;
  return matches[0];
}
function matchRegexProtocol(url, regex) {
  const protocol = getUrlProtocol(url);
  if (typeof protocol === "undefined")
    return false;
  return new RegExp(regex).test(protocol);
}
function isHttpUrl(url) {
  return matchRegexProtocol(url, HTTP_REGEX);
}
function isWsUrl(url) {
  return matchRegexProtocol(url, WS_REGEX);
}
function isLocalhostUrl(url) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(url);
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/validators.js
function isJsonRpcPayload(payload) {
  return typeof payload === "object" && "id" in payload && "jsonrpc" in payload && payload.jsonrpc === "2.0";
}
function isJsonRpcRequest(payload) {
  return isJsonRpcPayload(payload) && "method" in payload;
}
function isJsonRpcResponse(payload) {
  return isJsonRpcPayload(payload) && (isJsonRpcResult(payload) || isJsonRpcError(payload));
}
function isJsonRpcResult(payload) {
  return "result" in payload;
}
function isJsonRpcError(payload) {
  return "error" in payload;
}
function isJsonRpcValidationInvalid(validation) {
  return "error" in validation && validation.valid === false;
}

// node_modules/@walletconnect/jsonrpc-http-connection/dist/index.es.js
var import_events = __toESM(require_events());
var import_cross_fetch = __toESM(require_browser_ponyfill());
var P2 = Object.defineProperty;
var w2 = Object.defineProperties;
var E2 = Object.getOwnPropertyDescriptors;
var c2 = Object.getOwnPropertySymbols;
var L2 = Object.prototype.hasOwnProperty;
var O2 = Object.prototype.propertyIsEnumerable;
var l2 = (r2, t, e2) => t in r2 ? P2(r2, t, { enumerable: true, configurable: true, writable: true, value: e2 }) : r2[t] = e2;
var p2 = (r2, t) => {
  for (var e2 in t || (t = {})) L2.call(t, e2) && l2(r2, e2, t[e2]);
  if (c2) for (var e2 of c2(t)) O2.call(t, e2) && l2(r2, e2, t[e2]);
  return r2;
};
var v2 = (r2, t) => w2(r2, E2(t));
var j2 = { Accept: "application/json", "Content-Type": "application/json" };
var T2 = "POST";
var d2 = { headers: j2, method: T2 };
var g2 = 10;
var f2 = class {
  constructor(t, e2 = false) {
    if (this.url = t, this.disableProviderPing = e2, this.events = new import_events.EventEmitter(), this.isAvailable = false, this.registering = false, !isHttpUrl(t)) throw new Error(`Provided URL is not compatible with HTTP connection: ${t}`);
    this.url = t, this.disableProviderPing = e2;
  }
  get connected() {
    return this.isAvailable;
  }
  get connecting() {
    return this.registering;
  }
  on(t, e2) {
    this.events.on(t, e2);
  }
  once(t, e2) {
    this.events.once(t, e2);
  }
  off(t, e2) {
    this.events.off(t, e2);
  }
  removeListener(t, e2) {
    this.events.removeListener(t, e2);
  }
  async open(t = this.url) {
    await this.register(t);
  }
  async close() {
    if (!this.isAvailable) throw new Error("Connection already closed");
    this.onClose();
  }
  async send(t) {
    this.isAvailable || await this.register();
    try {
      const e2 = safeJsonStringify(t), s2 = await (await (0, import_cross_fetch.default)(this.url, v2(p2({}, d2), { body: e2 }))).json();
      this.onPayload({ data: s2 });
    } catch (e2) {
      this.onError(t.id, e2);
    }
  }
  async register(t = this.url) {
    if (!isHttpUrl(t)) throw new Error(`Provided URL is not compatible with HTTP connection: ${t}`);
    if (this.registering) {
      const e2 = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= e2 || this.events.listenerCount("open") >= e2) && this.events.setMaxListeners(e2 + 1), new Promise((s2, i2) => {
        this.events.once("register_error", (n3) => {
          this.resetMaxListeners(), i2(n3);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.isAvailable > "u") return i2(new Error("HTTP connection is missing or invalid"));
          s2();
        });
      });
    }
    this.url = t, this.registering = true;
    try {
      if (!this.disableProviderPing) {
        const e2 = safeJsonStringify({ id: 1, jsonrpc: "2.0", method: "test", params: [] });
        await (0, import_cross_fetch.default)(t, v2(p2({}, d2), { body: e2 }));
      }
      this.onOpen();
    } catch (e2) {
      const s2 = this.parseError(e2);
      throw this.events.emit("register_error", s2), this.onClose(), s2;
    }
  }
  onOpen() {
    this.isAvailable = true, this.registering = false, this.events.emit("open");
  }
  onClose() {
    this.isAvailable = false, this.registering = false, this.events.emit("close");
  }
  onPayload(t) {
    if (typeof t.data > "u") return;
    const e2 = typeof t.data == "string" ? safeJsonParse(t.data) : t.data;
    this.events.emit("payload", e2);
  }
  onError(t, e2) {
    const s2 = this.parseError(e2), i2 = s2.message || s2.toString(), n3 = formatJsonRpcError(t, i2);
    this.events.emit("payload", n3);
  }
  parseError(t, e2 = this.url) {
    return parseConnectionError(t, e2, "HTTP");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > g2 && this.events.setMaxListeners(g2);
  }
};

// node_modules/@walletconnect/jsonrpc-provider/dist/index.es.js
var import_events2 = __toESM(require_events());
var o3 = class extends r {
  constructor(t) {
    super(t), this.events = new import_events2.EventEmitter(), this.hasRegisteredEventListeners = false, this.connection = this.setConnection(t), this.connection.connected && this.registerEventListeners();
  }
  async connect(t = this.connection) {
    await this.open(t);
  }
  async disconnect() {
    await this.close();
  }
  on(t, e2) {
    this.events.on(t, e2);
  }
  once(t, e2) {
    this.events.once(t, e2);
  }
  off(t, e2) {
    this.events.off(t, e2);
  }
  removeListener(t, e2) {
    this.events.removeListener(t, e2);
  }
  async request(t, e2) {
    return this.requestStrict(formatJsonRpcRequest(t.method, t.params || [], t.id || getBigIntRpcId().toString()), e2);
  }
  async requestStrict(t, e2) {
    return new Promise(async (i2, s2) => {
      if (!this.connection.connected) try {
        await this.open();
      } catch (n3) {
        s2(n3);
      }
      this.events.on(`${t.id}`, (n3) => {
        isJsonRpcError(n3) ? s2(n3.error) : i2(n3.result);
      });
      try {
        await this.connection.send(t, e2);
      } catch (n3) {
        s2(n3);
      }
    });
  }
  setConnection(t = this.connection) {
    return t;
  }
  onPayload(t) {
    this.events.emit("payload", t), isJsonRpcResponse(t) ? this.events.emit(`${t.id}`, t) : this.events.emit("message", { type: t.method, data: t.params });
  }
  onClose(t) {
    t && t.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${t.code} ${t.reason ? `(${t.reason})` : ""}`)), this.events.emit("disconnect");
  }
  async open(t = this.connection) {
    this.connection === t && this.connection.connected || (this.connection.connected && this.close(), typeof t == "string" && (await this.connection.open(t), t = this.connection), this.connection = this.setConnection(t), await this.connection.open(), this.registerEventListeners(), this.events.emit("connect"));
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    this.hasRegisteredEventListeners || (this.connection.on("payload", (t) => this.onPayload(t)), this.connection.on("close", (t) => this.onClose(t)), this.connection.on("error", (t) => this.events.emit("error", t)), this.connection.on("register_error", (t) => this.onClose()), this.hasRegisteredEventListeners = true);
  }
};

// node_modules/destr/dist/index.mjs
var suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/;
var suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
var JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function jsonParseTransform(key, value) {
  if (key === "__proto__" || key === "constructor" && value && typeof value === "object" && "prototype" in value) {
    warnKeyDropped(key);
    return;
  }
  return value;
}
function warnKeyDropped(key) {
  console.warn(`[destr] Dropping "${key}" key to prevent prototype pollution.`);
}
function destr(value, options = {}) {
  if (typeof value !== "string") {
    return value;
  }
  if (value[0] === '"' && value[value.length - 1] === '"' && value.indexOf("\\") === -1) {
    return value.slice(1, -1);
  }
  const _value = value.trim();
  if (_value.length <= 9) {
    switch (_value.toLowerCase()) {
      case "true": {
        return true;
      }
      case "false": {
        return false;
      }
      case "undefined": {
        return void 0;
      }
      case "null": {
        return null;
      }
      case "nan": {
        return Number.NaN;
      }
      case "infinity": {
        return Number.POSITIVE_INFINITY;
      }
      case "-infinity": {
        return Number.NEGATIVE_INFINITY;
      }
    }
  }
  if (!JsonSigRx.test(value)) {
    if (options.strict) {
      throw new SyntaxError("[destr] Invalid JSON");
    }
    return value;
  }
  try {
    if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {
      if (options.strict) {
        throw new Error("[destr] Possible prototype pollution");
      }
      return JSON.parse(value, jsonParseTransform);
    }
    return JSON.parse(value);
  } catch (error) {
    if (options.strict) {
      throw error;
    }
    return value;
  }
}

// node_modules/unstorage/dist/shared/unstorage.CoCt7NXC.mjs
function wrapToPromise(value) {
  if (!value || typeof value.then !== "function") {
    return Promise.resolve(value);
  }
  return value;
}
function asyncCall(function_, ...arguments_) {
  try {
    return wrapToPromise(function_(...arguments_));
  } catch (error) {
    return Promise.reject(error);
  }
}
function isPrimitive(value) {
  const type = typeof value;
  return value === null || type !== "object" && type !== "function";
}
function isPureObject(value) {
  const proto = Object.getPrototypeOf(value);
  return !proto || proto.isPrototypeOf(Object);
}
function stringify(value) {
  if (isPrimitive(value)) {
    return String(value);
  }
  if (isPureObject(value) || Array.isArray(value)) {
    return JSON.stringify(value);
  }
  if (typeof value.toJSON === "function") {
    return stringify(value.toJSON());
  }
  throw new Error("[unstorage] Cannot stringify value!");
}
var BASE64_PREFIX = "base64:";
function serializeRaw(value) {
  if (typeof value === "string") {
    return value;
  }
  return BASE64_PREFIX + base64Encode(value);
}
function deserializeRaw(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (!value.startsWith(BASE64_PREFIX)) {
    return value;
  }
  return base64Decode(value.slice(BASE64_PREFIX.length));
}
function base64Decode(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input, "base64");
  }
  return Uint8Array.from(
    globalThis.atob(input),
    (c5) => c5.codePointAt(0)
  );
}
function base64Encode(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input).toString("base64");
  }
  return globalThis.btoa(String.fromCodePoint(...input));
}
function normalizeKey(key) {
  var _a;
  if (!key) {
    return "";
  }
  return ((_a = key.split("?")[0]) == null ? void 0 : _a.replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "")) || "";
}
function joinKeys(...keys2) {
  return normalizeKey(keys2.join(":"));
}
function normalizeBaseKey(base) {
  base = normalizeKey(base);
  return base ? base + ":" : "";
}
function filterKeyByDepth(key, depth) {
  if (depth === void 0) {
    return true;
  }
  let substrCount = 0;
  let index = key.indexOf(":");
  while (index > -1) {
    substrCount++;
    index = key.indexOf(":", index + 1);
  }
  return substrCount <= depth;
}
function filterKeyByBase(key, base) {
  if (base) {
    return key.startsWith(base) && key[key.length - 1] !== "$";
  }
  return key[key.length - 1] !== "$";
}

// node_modules/unstorage/dist/index.mjs
function defineDriver(factory) {
  return factory;
}
var DRIVER_NAME = "memory";
var memory = defineDriver(() => {
  const data = /* @__PURE__ */ new Map();
  return {
    name: DRIVER_NAME,
    getInstance: () => data,
    hasItem(key) {
      return data.has(key);
    },
    getItem(key) {
      return data.get(key) ?? null;
    },
    getItemRaw(key) {
      return data.get(key) ?? null;
    },
    setItem(key, value) {
      data.set(key, value);
    },
    setItemRaw(key, value) {
      data.set(key, value);
    },
    removeItem(key) {
      data.delete(key);
    },
    getKeys() {
      return [...data.keys()];
    },
    clear() {
      data.clear();
    },
    dispose() {
      data.clear();
    }
  };
});
function createStorage(options = {}) {
  const context = {
    mounts: { "": options.driver || memory() },
    mountpoints: [""],
    watching: false,
    watchListeners: [],
    unwatch: {}
  };
  const getMount = (key) => {
    for (const base of context.mountpoints) {
      if (key.startsWith(base)) {
        return {
          base,
          relativeKey: key.slice(base.length),
          driver: context.mounts[base]
        };
      }
    }
    return {
      base: "",
      relativeKey: key,
      driver: context.mounts[""]
    };
  };
  const getMounts = (base, includeParent) => {
    return context.mountpoints.filter(
      (mountpoint) => mountpoint.startsWith(base) || includeParent && base.startsWith(mountpoint)
    ).map((mountpoint) => ({
      relativeBase: base.length > mountpoint.length ? base.slice(mountpoint.length) : void 0,
      mountpoint,
      driver: context.mounts[mountpoint]
    }));
  };
  const onChange = (event, key) => {
    if (!context.watching) {
      return;
    }
    key = normalizeKey(key);
    for (const listener of context.watchListeners) {
      listener(event, key);
    }
  };
  const startWatch = async () => {
    if (context.watching) {
      return;
    }
    context.watching = true;
    for (const mountpoint in context.mounts) {
      context.unwatch[mountpoint] = await watch(
        context.mounts[mountpoint],
        onChange,
        mountpoint
      );
    }
  };
  const stopWatch = async () => {
    if (!context.watching) {
      return;
    }
    for (const mountpoint in context.unwatch) {
      await context.unwatch[mountpoint]();
    }
    context.unwatch = {};
    context.watching = false;
  };
  const runBatch = (items, commonOptions, cb) => {
    const batches = /* @__PURE__ */ new Map();
    const getBatch = (mount) => {
      let batch = batches.get(mount.base);
      if (!batch) {
        batch = {
          driver: mount.driver,
          base: mount.base,
          items: []
        };
        batches.set(mount.base, batch);
      }
      return batch;
    };
    for (const item of items) {
      const isStringItem = typeof item === "string";
      const key = normalizeKey(isStringItem ? item : item.key);
      const value = isStringItem ? void 0 : item.value;
      const options2 = isStringItem || !item.options ? commonOptions : { ...commonOptions, ...item.options };
      const mount = getMount(key);
      getBatch(mount).items.push({
        key,
        value,
        relativeKey: mount.relativeKey,
        options: options2
      });
    }
    return Promise.all([...batches.values()].map((batch) => cb(batch))).then(
      (r2) => r2.flat()
    );
  };
  const storage = {
    // Item
    hasItem(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.hasItem, relativeKey, opts);
    },
    getItem(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => destr(value)
      );
    },
    getItems(items, commonOptions = {}) {
      return runBatch(items, commonOptions, (batch) => {
        if (batch.driver.getItems) {
          return asyncCall(
            batch.driver.getItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              options: item.options
            })),
            commonOptions
          ).then(
            (r2) => r2.map((item) => ({
              key: joinKeys(batch.base, item.key),
              value: destr(item.value)
            }))
          );
        }
        return Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.getItem,
              item.relativeKey,
              item.options
            ).then((value) => ({
              key: item.key,
              value: destr(value)
            }));
          })
        );
      });
    },
    getItemRaw(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.getItemRaw) {
        return asyncCall(driver.getItemRaw, relativeKey, opts);
      }
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => deserializeRaw(value)
      );
    },
    async setItem(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key);
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.setItem) {
        return;
      }
      await asyncCall(driver.setItem, relativeKey, stringify(value), opts);
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async setItems(items, commonOptions) {
      await runBatch(items, commonOptions, async (batch) => {
        if (batch.driver.setItems) {
          return asyncCall(
            batch.driver.setItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              value: stringify(item.value),
              options: item.options
            })),
            commonOptions
          );
        }
        if (!batch.driver.setItem) {
          return;
        }
        await Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.setItem,
              item.relativeKey,
              stringify(item.value),
              item.options
            );
          })
        );
      });
    },
    async setItemRaw(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key, opts);
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.setItemRaw) {
        await asyncCall(driver.setItemRaw, relativeKey, value, opts);
      } else if (driver.setItem) {
        await asyncCall(driver.setItem, relativeKey, serializeRaw(value), opts);
      } else {
        return;
      }
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async removeItem(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { removeMeta: opts };
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.removeItem) {
        return;
      }
      await asyncCall(driver.removeItem, relativeKey, opts);
      if (opts.removeMeta || opts.removeMata) {
        await asyncCall(driver.removeItem, relativeKey + "$", opts);
      }
      if (!driver.watch) {
        onChange("remove", key);
      }
    },
    // Meta
    async getMeta(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { nativeOnly: opts };
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      const meta = /* @__PURE__ */ Object.create(null);
      if (driver.getMeta) {
        Object.assign(meta, await asyncCall(driver.getMeta, relativeKey, opts));
      }
      if (!opts.nativeOnly) {
        const value = await asyncCall(
          driver.getItem,
          relativeKey + "$",
          opts
        ).then((value_) => destr(value_));
        if (value && typeof value === "object") {
          if (typeof value.atime === "string") {
            value.atime = new Date(value.atime);
          }
          if (typeof value.mtime === "string") {
            value.mtime = new Date(value.mtime);
          }
          Object.assign(meta, value);
        }
      }
      return meta;
    },
    setMeta(key, value, opts = {}) {
      return this.setItem(key + "$", value, opts);
    },
    removeMeta(key, opts = {}) {
      return this.removeItem(key + "$", opts);
    },
    // Keys
    async getKeys(base, opts = {}) {
      var _a;
      base = normalizeBaseKey(base);
      const mounts = getMounts(base, true);
      let maskedMounts = [];
      const allKeys = [];
      let allMountsSupportMaxDepth = true;
      for (const mount of mounts) {
        if (!((_a = mount.driver.flags) == null ? void 0 : _a.maxDepth)) {
          allMountsSupportMaxDepth = false;
        }
        const rawKeys = await asyncCall(
          mount.driver.getKeys,
          mount.relativeBase,
          opts
        );
        for (const key of rawKeys) {
          const fullKey = mount.mountpoint + normalizeKey(key);
          if (!maskedMounts.some((p3) => fullKey.startsWith(p3))) {
            allKeys.push(fullKey);
          }
        }
        maskedMounts = [
          mount.mountpoint,
          ...maskedMounts.filter((p3) => !p3.startsWith(mount.mountpoint))
        ];
      }
      const shouldFilterByDepth = opts.maxDepth !== void 0 && !allMountsSupportMaxDepth;
      return allKeys.filter(
        (key) => (!shouldFilterByDepth || filterKeyByDepth(key, opts.maxDepth)) && filterKeyByBase(key, base)
      );
    },
    // Utils
    async clear(base, opts = {}) {
      base = normalizeBaseKey(base);
      await Promise.all(
        getMounts(base, false).map(async (m3) => {
          if (m3.driver.clear) {
            return asyncCall(m3.driver.clear, m3.relativeBase, opts);
          }
          if (m3.driver.removeItem) {
            const keys2 = await m3.driver.getKeys(m3.relativeBase || "", opts);
            return Promise.all(
              keys2.map((key) => m3.driver.removeItem(key, opts))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(context.mounts).map((driver) => dispose(driver))
      );
    },
    async watch(callback) {
      await startWatch();
      context.watchListeners.push(callback);
      return async () => {
        context.watchListeners = context.watchListeners.filter(
          (listener) => listener !== callback
        );
        if (context.watchListeners.length === 0) {
          await stopWatch();
        }
      };
    },
    async unwatch() {
      context.watchListeners = [];
      await stopWatch();
    },
    // Mount
    mount(base, driver) {
      base = normalizeBaseKey(base);
      if (base && context.mounts[base]) {
        throw new Error(`already mounted at ${base}`);
      }
      if (base) {
        context.mountpoints.push(base);
        context.mountpoints.sort((a, b2) => b2.length - a.length);
      }
      context.mounts[base] = driver;
      if (context.watching) {
        Promise.resolve(watch(driver, onChange, base)).then((unwatcher) => {
          context.unwatch[base] = unwatcher;
        }).catch(console.error);
      }
      return storage;
    },
    async unmount(base, _dispose = true) {
      var _a, _b;
      base = normalizeBaseKey(base);
      if (!base || !context.mounts[base]) {
        return;
      }
      if (context.watching && base in context.unwatch) {
        (_b = (_a = context.unwatch)[base]) == null ? void 0 : _b.call(_a);
        delete context.unwatch[base];
      }
      if (_dispose) {
        await dispose(context.mounts[base]);
      }
      context.mountpoints = context.mountpoints.filter((key) => key !== base);
      delete context.mounts[base];
    },
    getMount(key = "") {
      key = normalizeKey(key) + ":";
      const m3 = getMount(key);
      return {
        driver: m3.driver,
        base: m3.base
      };
    },
    getMounts(base = "", opts = {}) {
      base = normalizeKey(base);
      const mounts = getMounts(base, opts.parents);
      return mounts.map((m3) => ({
        driver: m3.driver,
        base: m3.mountpoint
      }));
    },
    // Aliases
    keys: (base, opts = {}) => storage.getKeys(base, opts),
    get: (key, opts = {}) => storage.getItem(key, opts),
    set: (key, value, opts = {}) => storage.setItem(key, value, opts),
    has: (key, opts = {}) => storage.hasItem(key, opts),
    del: (key, opts = {}) => storage.removeItem(key, opts),
    remove: (key, opts = {}) => storage.removeItem(key, opts)
  };
  return storage;
}
function watch(driver, onChange, base) {
  return driver.watch ? driver.watch((event, key) => onChange(event, base + key)) : () => {
  };
}
async function dispose(driver) {
  if (typeof driver.dispose === "function") {
    await asyncCall(driver.dispose);
  }
}

// node_modules/idb-keyval/dist/index.js
function promisifyRequest(request) {
  return new Promise((resolve, reject) => {
    request.oncomplete = request.onsuccess = () => resolve(request.result);
    request.onabort = request.onerror = () => reject(request.error);
  });
}
function createStore(dbName, storeName) {
  let dbp;
  const getDB = () => {
    if (dbp)
      return dbp;
    const request = indexedDB.open(dbName);
    request.onupgradeneeded = () => request.result.createObjectStore(storeName);
    dbp = promisifyRequest(request);
    dbp.then((db) => {
      db.onclose = () => dbp = void 0;
    }, () => {
    });
    return dbp;
  };
  return (txMode, callback) => getDB().then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));
}
var defaultGetStoreFunc;
function defaultGetStore() {
  if (!defaultGetStoreFunc) {
    defaultGetStoreFunc = createStore("keyval-store", "keyval");
  }
  return defaultGetStoreFunc;
}
function get(key, customStore = defaultGetStore()) {
  return customStore("readonly", (store) => promisifyRequest(store.get(key)));
}
function set(key, value, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.put(value, key);
    return promisifyRequest(store.transaction);
  });
}
function del(key, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.delete(key);
    return promisifyRequest(store.transaction);
  });
}
function clear(customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.clear();
    return promisifyRequest(store.transaction);
  });
}
function eachCursor(store, callback) {
  store.openCursor().onsuccess = function() {
    if (!this.result)
      return;
    callback(this.result);
    this.result.continue();
  };
  return promisifyRequest(store.transaction);
}
function keys(customStore = defaultGetStore()) {
  return customStore("readonly", (store) => {
    if (store.getAllKeys) {
      return promisifyRequest(store.getAllKeys());
    }
    const items = [];
    return eachCursor(store, (cursor) => items.push(cursor.key)).then(() => items);
  });
}

// node_modules/@walletconnect/keyvaluestorage/dist/index.es.js
var x3 = "idb-keyval";
var z2 = (i2 = {}) => {
  const t = i2.base && i2.base.length > 0 ? `${i2.base}:` : "", e2 = (s2) => t + s2;
  let n3;
  return i2.dbName && i2.storeName && (n3 = createStore(i2.dbName, i2.storeName)), { name: x3, options: i2, async hasItem(s2) {
    return !(typeof await get(e2(s2), n3) > "u");
  }, async getItem(s2) {
    return await get(e2(s2), n3) ?? null;
  }, setItem(s2, a) {
    return set(e2(s2), a, n3);
  }, removeItem(s2) {
    return del(e2(s2), n3);
  }, getKeys() {
    return keys(n3);
  }, clear() {
    return clear(n3);
  } };
};
var D = "WALLET_CONNECT_V2_INDEXED_DB";
var E3 = "keyvaluestorage";
var _2 = class {
  constructor() {
    this.indexedDb = createStorage({ driver: z2({ dbName: D, storeName: E3 }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((t) => [t.key, t.value]);
  }
  async getItem(t) {
    const e2 = await this.indexedDb.getItem(t);
    if (e2 !== null) return e2;
  }
  async setItem(t, e2) {
    await this.indexedDb.setItem(t, safeJsonStringify(e2));
  }
  async removeItem(t) {
    await this.indexedDb.removeItem(t);
  }
};
var l3 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
var c4 = { exports: {} };
(function() {
  let i2;
  function t() {
  }
  i2 = t, i2.prototype.getItem = function(e2) {
    return this.hasOwnProperty(e2) ? String(this[e2]) : null;
  }, i2.prototype.setItem = function(e2, n3) {
    this[e2] = String(n3);
  }, i2.prototype.removeItem = function(e2) {
    delete this[e2];
  }, i2.prototype.clear = function() {
    const e2 = this;
    Object.keys(e2).forEach(function(n3) {
      e2[n3] = void 0, delete e2[n3];
    });
  }, i2.prototype.key = function(e2) {
    return e2 = e2 || 0, Object.keys(this)[e2];
  }, i2.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof l3 < "u" && l3.localStorage ? c4.exports = l3.localStorage : typeof window < "u" && window.localStorage ? c4.exports = window.localStorage : c4.exports = new t();
})();
function k3(i2) {
  var t;
  return [i2[0], safeJsonParse((t = i2[1]) != null ? t : "")];
}
var K2 = class {
  constructor() {
    this.localStorage = c4.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(k3);
  }
  async getItem(t) {
    const e2 = this.localStorage.getItem(t);
    if (e2 !== null) return safeJsonParse(e2);
  }
  async setItem(t, e2) {
    this.localStorage.setItem(t, safeJsonStringify(e2));
  }
  async removeItem(t) {
    this.localStorage.removeItem(t);
  }
};
var N2 = "wc_storage_version";
var y2 = 1;
var O3 = async (i2, t, e2) => {
  const n3 = N2, s2 = await t.getItem(n3);
  if (s2 && s2 >= y2) {
    e2(t);
    return;
  }
  const a = await i2.getKeys();
  if (!a.length) {
    e2(t);
    return;
  }
  const m3 = [];
  for (; a.length; ) {
    const r2 = a.shift();
    if (!r2) continue;
    const o4 = r2.toLowerCase();
    if (o4.includes("wc@") || o4.includes("walletconnect") || o4.includes("wc_") || o4.includes("wallet_connect")) {
      const f3 = await i2.getItem(r2);
      await t.setItem(r2, f3), m3.push(r2);
    }
  }
  await t.setItem(n3, y2), e2(t), j3(i2, m3);
};
var j3 = async (i2, t) => {
  t.length && t.forEach(async (e2) => {
    await i2.removeItem(e2);
  });
};
var h2 = class {
  constructor() {
    this.initialized = false, this.setInitialized = (e2) => {
      this.storage = e2, this.initialized = true;
    };
    const t = new K2();
    this.storage = t;
    try {
      const e2 = new _2();
      O3(t, e2, this.setInitialized);
    } catch {
      this.initialized = true;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(t) {
    return await this.initialize(), this.storage.getItem(t);
  }
  async setItem(t, e2) {
    return await this.initialize(), this.storage.setItem(t, e2);
  }
  async removeItem(t) {
    return await this.initialize(), this.storage.removeItem(t);
  }
  async initialize() {
    this.initialized || await new Promise((t) => {
      const e2 = setInterval(() => {
        this.initialized && (clearInterval(e2), t());
      }, 20);
    });
  }
};

export {
  safeJsonParse,
  safeJsonStringify,
  h2 as h,
  IEvents,
  esm_exports2 as esm_exports,
  init_esm,
  import_pino2 as import_pino,
  k,
  y,
  E,
  A,
  Qe,
  sn,
  Po,
  Qo,
  parseConnectionError,
  payloadId,
  getBigIntRpcId,
  formatJsonRpcRequest,
  formatJsonRpcResult,
  formatJsonRpcError,
  r,
  isWsUrl,
  isLocalhostUrl,
  isJsonRpcRequest,
  isJsonRpcResponse,
  isJsonRpcResult,
  isJsonRpcError,
  esm_exports as esm_exports2,
  require_browser2 as require_browser,
  f2 as f,
  o3 as o
};
/*! Bundled license information:

@walletconnect/relay-auth/dist/index.es.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=chunk-PE5I4252.js.map
