{"version":3,"sources":["../src/index.ts","../src/utils.ts","../src/address.ts"],"sourcesContent":["export * from './utils';\nexport { default as Address } from './address';\n","import { randomBytes } from '@fuel-ts/crypto';\nimport { FuelError } from '@fuel-ts/errors';\nimport { AbstractContract, AbstractAccount } from '@fuel-ts/interfaces';\nimport type {\n  Bech32Address,\n  B256Address,\n  AddressLike,\n  ContractIdLike,\n  AbstractAddress,\n  B256AddressEvm,\n  BytesLike,\n} from '@fuel-ts/interfaces';\nimport { arrayify, hexlify } from '@fuel-ts/utils';\nimport type { Decoded } from 'bech32';\nimport { bech32m } from 'bech32';\n\n/**\n * Fuel Network HRP (human-readable part) for bech32 encoding\n *\n * @hidden\n */\nexport const FUEL_BECH32_HRP_PREFIX = 'fuel';\n\n/**\n * Decodes a Bech32 address string into Decoded\n * @deprecated\n * Type `Bech32Address` is now deprecated, as is this function. Use `B256` addresses instead. ([help](https://docs.fuel.network/docs/specs/abi/argument-encoding/#b256))\n * @hidden\n */\nexport function fromBech32(address: Bech32Address): Decoded {\n  return bech32m.decode(address);\n}\n\n/**\n * Converts a B256 address string into Bech32\n * @deprecated\n * Type `Bech32Address` is now deprecated, as is this function. Use `B256` addresses instead. ([help](https://docs.fuel.network/docs/specs/abi/argument-encoding/#b256))\n * @hidden\n */\nexport function toBech32(address: B256Address): Bech32Address {\n  return bech32m.encode(\n    FUEL_BECH32_HRP_PREFIX,\n    bech32m.toWords(arrayify(hexlify(address)))\n  ) as Bech32Address;\n}\n\n/**\n * Determines if a given string is Bech32 format\n * @deprecated\n * Type `Bech32Address` is now deprecated, as is this function. Use `B256` addresses instead. ([help](https://docs.fuel.network/docs/specs/abi/argument-encoding/#b256))\n * @hidden\n */\nexport function isBech32(address: BytesLike): boolean {\n  return (\n    typeof address === 'string' &&\n    address.indexOf(FUEL_BECH32_HRP_PREFIX + 1) === 0 &&\n    fromBech32(address as Bech32Address).prefix === FUEL_BECH32_HRP_PREFIX\n  );\n}\n\n/**\n * Determines if a given string is B256 format\n *\n * @hidden\n */\nexport function isB256(address: string): boolean {\n  return address.length === 66 && /(0x)[0-9a-f]{64}$/i.test(address);\n}\n\n/**\n * Determines if a given string is in Public Key format (512 bits)\n *\n * @hidden\n */\nexport function isPublicKey(address: string): boolean {\n  return address.length === 130 && /(0x)[0-9a-f]{128}$/i.test(address);\n}\n\n/**\n * Determines if a given string is in EVM Address format\n *\n * @hidden\n */\nexport function isEvmAddress(address: string): boolean {\n  return address.length === 42 && /(0x)[0-9a-f]{40}$/i.test(address);\n}\n\n/**\n * Takes a Bech32 address and returns the byte data\n * @deprecated\n * The `bech32Address` is now deprecated. Please migrate to B256 format (see https://docs.fuel.network/docs/specs/abi/argument-encoding/#b256 for more details) as this will be the standard going forward.\n * @hidden\n */\nexport function getBytesFromBech32(address: Bech32Address): Uint8Array {\n  return new Uint8Array(bech32m.fromWords(fromBech32(address).words));\n}\n\n/**\n * Converts a Bech32 address string into B256\n * @hidden\n */\nexport function toB256(address: Bech32Address): B256Address {\n  if (!isBech32(address)) {\n    throw new FuelError(\n      FuelError.CODES.INVALID_BECH32_ADDRESS,\n      `Invalid Bech32 Address: ${address}.`\n    );\n  }\n\n  return hexlify(getBytesFromBech32(address));\n}\n\n/**\n * Takes a Bech32 address and returns a normalized (i.e. lower case) representation of it.\n *\n * The input is validated along the way, which makes this significantly safer than\n * using `address.toLowerCase()`.\n *\n * @hidden\n */\nexport function normalizeBech32(address: Bech32Address): Bech32Address {\n  const { words } = fromBech32(address);\n  return bech32m.encode(FUEL_BECH32_HRP_PREFIX, words) as Bech32Address;\n}\n\n/**\n * Takes an indeterminate address type and returns an address\n *\n * @hidden\n */\nexport const addressify = (addressLike: AddressLike | ContractIdLike): AbstractAddress => {\n  if (addressLike instanceof AbstractAccount) {\n    return addressLike.address;\n  }\n\n  if (addressLike instanceof AbstractContract) {\n    return addressLike.id;\n  }\n\n  return addressLike;\n};\n\n/**\n * @hidden\n */\nexport const getRandomB256 = () => hexlify(randomBytes(32));\n\n/**\n * Takes a B256 address and clears the first 12 bytes, this is required for an EVM Address\n *\n * @param b256 - the address to clear\n * @returns b256 with first 12 bytes cleared\n *\n * @hidden\n */\nexport const clearFirst12BytesFromB256 = (b256: B256Address): B256AddressEvm => {\n  let bytes;\n\n  try {\n    if (!isB256(b256)) {\n      throw new FuelError(\n        FuelError.CODES.INVALID_BECH32_ADDRESS,\n        `Invalid Bech32 Address: ${b256}.`\n      );\n    }\n\n    bytes = getBytesFromBech32(toBech32(b256));\n    bytes = hexlify(bytes.fill(0, 0, 12)) as B256AddressEvm;\n  } catch (error) {\n    throw new FuelError(\n      FuelError.CODES.PARSE_FAILED,\n      `Cannot generate EVM Address B256 from: ${b256}.`\n    );\n  }\n\n  return bytes;\n};\n\n/**\n * Pads the first 12 bytes of an Evm address. This is useful for padding addresses returned from\n * the EVM to interact with the Sway EVM Address Type.\n *\n * @param address - Evm address to be padded\n * @returns Evm address padded to a b256 address\n *\n * @hidden\n */\nexport const padFirst12BytesOfEvmAddress = (address: string): B256AddressEvm => {\n  if (!isEvmAddress(address)) {\n    throw new FuelError(FuelError.CODES.INVALID_EVM_ADDRESS, 'Invalid EVM address format.');\n  }\n\n  return address.replace('0x', '0x000000000000000000000000') as B256AddressEvm;\n};\n","import { FuelError } from '@fuel-ts/errors';\nimport { AbstractAddress } from '@fuel-ts/interfaces';\nimport type {\n  Bech32Address,\n  B256Address,\n  EvmAddress,\n  AssetId,\n  ChecksumAddress,\n} from '@fuel-ts/interfaces';\nimport { arrayify, hexlify } from '@fuel-ts/utils';\nimport { sha256 } from '@noble/hashes/sha256';\n\nimport {\n  normalizeBech32,\n  isBech32,\n  toB256,\n  getBytesFromBech32,\n  toBech32,\n  getRandomB256,\n  isPublicKey,\n  isB256,\n  clearFirst12BytesFromB256,\n  isEvmAddress,\n  padFirst12BytesOfEvmAddress,\n} from './utils';\n\n/**\n * `Address` provides a type safe wrapper for converting between different address formats\n * ands comparing them for equality.\n */\nexport default class Address extends AbstractAddress {\n  // #region address-2\n  /**\n   * @deprecated\n   * Type `Bech32Address` is now deprecated, as is this property. Use `B256` addresses instead. ([help](https://docs.fuel.network/docs/specs/abi/argument-encoding/#b256))\n   */\n  readonly bech32Address: Bech32Address;\n  // #endregion address-2\n\n  /**\n   * @param address - A Bech32 address or B256 address\n   */\n  constructor(address: Bech32Address | B256Address) {\n    super();\n\n    if (isB256(address)) {\n      this.bech32Address = toBech32(address);\n    } else {\n      this.bech32Address = normalizeBech32(address as Bech32Address);\n\n      if (!isBech32(this.bech32Address)) {\n        throw new FuelError(\n          FuelError.CODES.INVALID_BECH32_ADDRESS,\n          `Invalid Bech32 Address: ${this.bech32Address}.`\n        );\n      }\n    }\n  }\n\n  /**\n   * Takes an B256 Address and returns back an checksum address.\n   * The implementation follows the ERC-55 https://github.com/ethereum/ercs/blob/master/ERCS/erc-55.md.\n   *\n   * @returns A new `ChecksumAddress` instance\n   */\n  toChecksum(): ChecksumAddress {\n    return Address.toChecksum(this.toB256());\n  }\n\n  /**\n   * Returns the `bech32Address` property\n   * @deprecated\n   * Type `Bech32Address` is now deprecated, as is this method. Use `B256` addresses instead. ([help](https://docs.fuel.network/docs/specs/abi/argument-encoding/#b256))\n   * @returns The `bech32Address` property\n   */\n  toAddress(): Bech32Address {\n    return this.bech32Address;\n  }\n\n  /**\n   * Converts and returns the `bech32Address` property to a 256 bit hash string\n   * @returns The `bech32Address` property as a 256 bit hash string\n   */\n  toB256(): B256Address {\n    return toB256(this.bech32Address);\n  }\n\n  /**\n   * Converts and returns the `bech32Address` property to a byte array\n   * @returns The `bech32Address` property as a byte array\n   */\n  toBytes(): Uint8Array {\n    return getBytesFromBech32(this.bech32Address);\n  }\n\n  /**\n   * Converts the `bech32Address` property to a 256 bit hash string\n   * @returns The `bech32Address` property as a 256 bit hash string\n   */\n  toHexString(): B256Address {\n    return this.toB256();\n  }\n\n  /**\n   * returns the address `checksum` as a string\n   *\n   * @returns The `bech32Address` property as a string\n   */\n  toString(): string {\n    return this.toChecksum();\n  }\n\n  /**\n   * Converts and returns the `bech32Address` property as a string\n   * @returns The `bech32Address` property as a JSON string\n   */\n  toJSON(): string {\n    return this.bech32Address;\n  }\n\n  /**\n   * Clears the first 12 bytes of the `bech32Address` property and returns it as a `EvmAddress`\n   * @returns The `bech32Address` property as an {@link EvmAddress | `EvmAddress`}\n   */\n  toEvmAddress(): EvmAddress {\n    const b256Address = toB256(this.bech32Address);\n\n    return {\n      bits: clearFirst12BytesFromB256(b256Address),\n    } as EvmAddress;\n  }\n\n  /**\n   * Wraps the B256 property and returns as an `AssetId`.\n   * @returns The B256 property as an {@link AssetId | `AssetId`}\n   */\n  toAssetId(): AssetId {\n    return {\n      bits: this.toB256(),\n    } as AssetId;\n  }\n\n  /**\n   * Wraps the B256 address `checksum` and returns it as a string\n   * @returns The B256 address `checksum` as a string\n   */\n  override valueOf(): string {\n    return this.toChecksum();\n  }\n\n  /**\n   * Compares this the `bech32Address` property to another for direct equality\n   * @param other - Another address to compare against\n   * @returns The equality of the comparison\n   */\n  equals(other: Address): boolean {\n    return this.bech32Address === other.bech32Address;\n  }\n\n  /**\n   * Takes a Public Key, hashes it, and creates an `Address`\n   *\n   * @param publicKey - A wallets public key\n   * @returns A new `Address` instance\n   */\n  static fromPublicKey(publicKey: string): Address {\n    if (!isPublicKey(publicKey)) {\n      throw new FuelError(FuelError.CODES.INVALID_PUBLIC_KEY, `Invalid Public Key: ${publicKey}.`);\n    }\n\n    const b256Address = hexlify(sha256(arrayify(publicKey)));\n    return new Address(toBech32(b256Address));\n  }\n\n  /**\n   * Takes a B256 Address and creates an `Address`\n   *\n   * @param b256Address - A b256 hash\n   * @returns A new `Address` instance\n   */\n  static fromB256(b256Address: string): Address {\n    if (!isB256(b256Address)) {\n      throw new FuelError(\n        FuelError.CODES.INVALID_B256_ADDRESS,\n        `Invalid B256 Address: ${b256Address}.`\n      );\n    }\n\n    return new Address(toBech32(b256Address));\n  }\n\n  /**\n   * Creates an `Address` with a randomized `bech32Address` property\n   *\n   * @returns A new `Address` instance\n   */\n  static fromRandom(): Address {\n    return this.fromB256(getRandomB256());\n  }\n\n  /**\n   * Takes an ambiguous string and attempts to create an `Address`\n   *\n   * @param address - An ambiguous string\n   * @returns A new `Address` instance\n   */\n  static fromString(address: string): Address {\n    return isBech32(address) ? new Address(address as Bech32Address) : this.fromB256(address);\n  }\n\n  /**\n   * Takes an ambiguous string or address and creates an `Address`\n   *\n   * @returns a new `Address` instance\n   */\n  static fromAddressOrString(address: string | AbstractAddress): AbstractAddress {\n    return typeof address === 'string' ? this.fromString(address) : address;\n  }\n\n  /**\n   * Takes a dynamic string or `AbstractAddress` and creates an `Address`\n   *\n   * @param addressId - A string containing Bech32, B256, or Public Key\n   * @throws Error - Unknown address if the format is not recognised\n   * @returns A new `Address` instance\n   */\n  static fromDynamicInput(address: string | AbstractAddress): Address {\n    // If address is a object than we assume it's a AbstractAddress\n    // we don't check by instanceof because it's possible to\n    // the host app to have a different reference to this same class type\n    if (typeof address !== 'string' && 'toB256' in address) {\n      return Address.fromB256(address.toB256());\n    }\n    if (isPublicKey(address)) {\n      return Address.fromPublicKey(address);\n    }\n\n    if (isBech32(address)) {\n      return new Address(address as Bech32Address);\n    }\n\n    if (isB256(address)) {\n      return Address.fromB256(address);\n    }\n\n    if (isEvmAddress(address)) {\n      return Address.fromEvmAddress(address);\n    }\n\n    throw new FuelError(\n      FuelError.CODES.PARSE_FAILED,\n      `Unknown address format: only 'Bech32', 'B256', or 'Public Key (512)' are supported.`\n    );\n  }\n\n  /**\n   * Takes an Evm Address and returns back an `Address`\n   *\n   * @returns A new `Address` instance\n   */\n  static fromEvmAddress(evmAddress: string): Address {\n    if (!isEvmAddress(evmAddress)) {\n      throw new FuelError(\n        FuelError.CODES.INVALID_EVM_ADDRESS,\n        `Invalid Evm Address: ${evmAddress}.`\n      );\n    }\n\n    const paddedAddress = padFirst12BytesOfEvmAddress(evmAddress);\n\n    return new Address(toBech32(paddedAddress));\n  }\n\n  /**\n   * Takes an ChecksumAddress and validates if it is a valid checksum address.\n   *\n   * @returns A `boolean` instance indicating if the address is valid.\n   */\n  static isChecksumValid(address: ChecksumAddress): boolean {\n    let addressParsed = address;\n\n    if (!address.startsWith('0x')) {\n      addressParsed = `0x${address}`;\n    }\n    if (addressParsed.trim().length !== 66) {\n      return false;\n    }\n\n    return Address.toChecksum(hexlify(addressParsed)) === addressParsed;\n  }\n\n  /** @hidden */\n  private static toChecksum(address: string) {\n    if (!isB256(address)) {\n      throw new FuelError(\n        FuelError.CODES.INVALID_B256_ADDRESS,\n        `Invalid B256 Address: ${address}.`\n      );\n    }\n\n    const addressHex = hexlify(address).toLowerCase().slice(2);\n    const checksum = sha256(addressHex);\n\n    let ret = '0x';\n    for (let i = 0; i < 32; ++i) {\n      const byte = checksum[i];\n      const ha = addressHex.charAt(i * 2);\n      const hb = addressHex.charAt(i * 2 + 1);\n      ret += (byte & 0xf0) >= 0x80 ? ha.toUpperCase() : ha;\n      ret += (byte & 0x0f) >= 0x08 ? hb.toUpperCase() : hb;\n    }\n\n    return ret;\n  }\n}\n"],"mappings":"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","names":["import_errors","import_interfaces","import_utils"]}