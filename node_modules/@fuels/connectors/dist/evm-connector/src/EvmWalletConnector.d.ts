import { type ConnectorMetadata, FuelConnectorEventTypes, Provider, type TransactionRequestLike } from 'fuels';
import { type Maybe, type MaybeAsync, PredicateConnector, type PredicateVersion, type PredicateWalletAdapter, type ProviderDictionary } from '@fuel-connectors/common';
import { type EIP1193Provider, type EVMWalletConnectorConfig, EVMWalletConnectorEvents } from './types';
export declare class EVMWalletConnector extends PredicateConnector {
    name: string;
    metadata: ConnectorMetadata;
    ethProvider: EIP1193Provider | null;
    fuelProvider: Provider | null;
    events: {
        ACCOUNTS_CHANGED: EVMWalletConnectorEvents.ACCOUNTS_CHANGED;
        CONNECT: EVMWalletConnectorEvents.CONNECT;
        DISCONNECT: EVMWalletConnectorEvents.DISCONNECT;
        connectors: FuelConnectorEventTypes.connectors;
        currentConnector: FuelConnectorEventTypes.currentConnector;
        connection: FuelConnectorEventTypes.connection;
        accounts: FuelConnectorEventTypes.accounts;
        currentAccount: FuelConnectorEventTypes.currentAccount;
        networks: FuelConnectorEventTypes.networks;
        currentNetwork: FuelConnectorEventTypes.currentNetwork;
        assets: FuelConnectorEventTypes.assets;
        abis: FuelConnectorEventTypes.abis;
    };
    private setupLock;
    private _currentAccount;
    private config;
    private _ethereumEvents;
    constructor(config?: EVMWalletConnectorConfig);
    private getLazyEthereum;
    private setUpEvents;
    private setup;
    private setupEventBridge;
    private setupCurrentAccount;
    protected getWalletAdapter(): PredicateWalletAdapter;
    protected getPredicateVersions(): Record<string, PredicateVersion>;
    protected requireConnection(): MaybeAsync<void>;
    protected configProviders(config?: EVMWalletConnectorConfig): Promise<void>;
    protected walletAccounts(): Promise<Array<string>>;
    protected getAccountAddress(): Promise<Maybe<string>>;
    protected getProviders(): Promise<ProviderDictionary>;
    ping(): Promise<boolean>;
    connect(): Promise<boolean>;
    disconnect(): Promise<boolean>;
    sendTransaction(address: string, transaction: TransactionRequestLike): Promise<string>;
    signMessageCustomCurve(message: string): Promise<{
        curve: string;
        signature: string;
    }>;
    private isValidPredicateAddress;
    private encodeTxId;
}
