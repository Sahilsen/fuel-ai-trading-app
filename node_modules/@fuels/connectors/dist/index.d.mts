import { JsonAbi, BytesLike, Provider, Predicate, InputValue, TransactionRequest, B256Address, BN, FuelConnector, FuelConnectorEventTypes, ConnectorMetadata, TransactionRequestLike, Version, Network, Asset, SelectNetworkArguments, AbiMap, FuelConfig, StorageAbstract, FuelConnectorSendTxParams, FuelABI, ConnectorEvent } from 'fuels';
import memoize from 'memoizee';
import EventEmitter from 'node:events';
import { Config } from '@wagmi/core';
import { ProviderType } from '@web3modal/solana/dist/types/src/utils/scaffold';
import { JSONRPCClient, JSONRPCRequest, JSONRPCResponse } from 'json-rpc-2.0';

type Maybe<T> = T | undefined | null;
type Option<T1, T2, T3 = string> = T1 | T2 | T3;
type Hash = `0x${string}`;
type MaybeAsync<T> = Promise<T> | T;
interface PredicateConfig {
    abi: JsonAbi;
    bin: BytesLike;
}
interface PredicateVersion {
    predicate: PredicateConfig;
    generatedAt: number;
}
interface EIP1193Provider extends EventEmitter {
    request(args: {
        method: string;
        params?: unknown[];
    }): Promise<unknown | unknown[]>;
}
type ConnectorConfig = {
    [key: string]: unknown;
    predicateConfig?: PredicateConfig;
};
type ProviderDictionary = {
    fuelProvider: Provider;
    ethProvider?: EIP1193Provider;
    [key: string]: Maybe<Option<Provider, EIP1193Provider>>;
};
type PreparedTransaction = {
    predicate: Predicate<InputValue[]>;
    request: TransactionRequest;
    transactionId: string;
    account: string;
    transactionRequest: TransactionRequest;
};
type SignedMessageCustomCurve = {
    curve: string;
    signature: string;
};

interface FakeAccount {
    generate: () => void;
    getAddress: () => Option<string, Hash>;
    getRawAddress: () => Uint8Array;
    signMessage: (message: Option<string, Uint8Array, Hash>) => Promise<Option<string, Uint8Array, Hash>>;
}

interface PredicateWalletAdapter {
    convertAddress: (address: string) => string;
    generateFakeAccount: () => FakeAccount;
    buildWitnessData: (account: FakeAccount, signature: Option<string, Uint8Array, Hash>) => Array<Option<string, Uint8Array, Hash>>;
}

declare class PredicateFactory {
    private abi;
    private bytecode;
    private adapter;
    private root;
    private generatedAt;
    constructor(adapter: PredicateWalletAdapter, { abi, bin }: PredicateConfig, root: string, generatedAt?: number);
    getRoot: () => string;
    getPredicateAddress: ((address: string | B256Address) => string) & memoize.Memoized<(address: string | B256Address) => string>;
    build: (<T extends InputValue[]>(address: string | B256Address, provider: Provider, data?: T) => Predicate<T>) & memoize.Memoized<(<T extends InputValue[]>(address: string | B256Address, provider: Provider, data?: T) => Predicate<T>)>;
    getAccountAddress: (address: string, accounts?: Array<string>) => Maybe<string>;
    getPredicateAddresses: (accounts?: Array<string>) => Array<string>;
    getMaxPredicateGasUsed: ((provider: Provider) => Promise<BN>) & memoize.Memoized<(provider: Provider) => Promise<BN>>;
    equals: (predicate: Maybe<PredicateFactory>) => boolean;
    sort: (predicate: PredicateFactory) => number;
}

declare abstract class PredicateConnector extends FuelConnector {
    connected: boolean;
    installed: boolean;
    external: boolean;
    events: typeof FuelConnectorEventTypes;
    protected predicateAddress: string;
    protected customPredicate: Maybe<PredicateConfig>;
    protected predicateAccount: Maybe<PredicateFactory>;
    protected subscriptions: Array<() => void>;
    protected hasProviderSucceeded: boolean;
    private _predicateVersions;
    abstract name: string;
    abstract metadata: ConnectorMetadata;
    abstract sendTransaction(address: string, transaction: TransactionRequestLike): Promise<string>;
    abstract connect(): Promise<boolean>;
    abstract disconnect(): Promise<boolean>;
    protected abstract configProviders(config: ConnectorConfig): MaybeAsync<void>;
    protected abstract getWalletAdapter(): PredicateWalletAdapter;
    protected abstract getPredicateVersions(): Record<string, PredicateVersion>;
    protected abstract getAccountAddress(): MaybeAsync<Maybe<string>>;
    protected abstract getProviders(): Promise<ProviderDictionary>;
    protected abstract requireConnection(): MaybeAsync<void>;
    protected abstract walletAccounts(): Promise<Array<string>>;
    abstract signMessageCustomCurve(_message: string): Promise<SignedMessageCustomCurve>;
    protected emitAccountChange(address: string, connected?: boolean): Promise<void>;
    protected get predicateVersions(): Array<PredicateFactory>;
    protected isAddressPredicate(b: BytesLike, walletAccount: string): boolean;
    protected getCurrentUserPredicate(): Promise<Maybe<PredicateFactory>>;
    protected getNewestPredicate(): Maybe<PredicateFactory>;
    protected setupPredicate(): Promise<PredicateFactory>;
    protected subscribe(listener: () => void): void;
    protected prepareTransaction(address: string, transaction: TransactionRequestLike): Promise<PreparedTransaction>;
    clearSubscriptions(): void;
    ping(): Promise<boolean>;
    version(): Promise<Version>;
    isConnected(): Promise<boolean>;
    accounts(): Promise<Array<string>>;
    currentAccount(): Promise<string | null>;
    networks(): Promise<Network[]>;
    currentNetwork(): Promise<Network>;
    signMessage(_address: string, _message: string): Promise<string>;
    addAssets(_assets: Asset[]): Promise<boolean>;
    addAsset(_asset: Asset): Promise<boolean>;
    assets(): Promise<Array<Asset>>;
    addNetwork(_networkUrl: string): Promise<boolean>;
    selectNetwork(_network: SelectNetworkArguments): Promise<boolean>;
    addAbi(_abiMap: AbiMap): Promise<boolean>;
    getAbi(_contractId: string): Promise<JsonAbi>;
    hasAbi(_contractId: string): Promise<boolean>;
}

declare function createConfig(func: () => FuelConfig): FuelConfig;
declare function hasSignMessageCustomCurve(connector?: FuelConnector | PredicateConnector | null): connector is PredicateConnector;

type BurnerWalletConfig = {
    fuelProvider?: Provider | Promise<Provider>;
    storage?: StorageAbstract;
    chainId?: number;
};

declare class BurnerWalletConnector extends FuelConnector {
    name: string;
    connected: boolean;
    installed: boolean;
    external: boolean;
    events: typeof FuelConnectorEventTypes;
    metadata: ConnectorMetadata;
    private burnerWallet;
    private fuelProvider;
    private storage;
    private config;
    constructor(config?: BurnerWalletConfig);
    private configProvider;
    private getProvider;
    private generatePrivateKey;
    private getPrivateKey;
    private getStatus;
    private setupBurnerWallet;
    private getStorage;
    /**
     * ============================================================
     * Connector methods
     * ============================================================
     */
    ping(): Promise<boolean>;
    version(): Promise<Version>;
    isConnected(): Promise<boolean>;
    connect(): Promise<boolean>;
    accounts(): Promise<string[]>;
    disconnect(): Promise<boolean>;
    signMessage(address: string, message: string): Promise<string>;
    sendTransaction(_address: string, transaction: TransactionRequestLike): Promise<string>;
    currentAccount(): Promise<string | null>;
    addAssets(_assets: Asset[]): Promise<boolean>;
    addAsset(_asset: Asset): Promise<boolean>;
    assets(): Promise<Array<Asset>>;
    addNetwork(_networkUrl: string): Promise<boolean>;
    selectNetwork(_network: SelectNetworkArguments): Promise<boolean>;
    networks(): Promise<Network[]>;
    currentNetwork(): Promise<Network>;
    addAbi(_abiMap: AbiMap): Promise<boolean>;
    getAbi(_contractId: string): Promise<JsonAbi>;
    hasAbi(_contractId: string): Promise<boolean>;
}

type DefaultConnectors = {
    devMode?: boolean;
    wcProjectId?: string;
    burnerWalletConfig?: BurnerWalletConfig;
    ethWagmiConfig?: Config;
    ethSkipAutoReconnect?: boolean;
    solanaConfig?: ProviderType;
    chainId?: number;
    fuelProvider?: Provider | Promise<Provider>;
};
declare function defaultConnectors({ devMode, wcProjectId, burnerWalletConfig, ethWagmiConfig, ethSkipAutoReconnect, solanaConfig: _solanaConfig, chainId, fuelProvider, }?: DefaultConnectors): Array<FuelConnector>;

declare const CONNECTOR_SCRIPT = "FuelConnectorScript";
declare const CONTENT_SCRIPT_NAME = "FuelContentScript";
declare const EVENT_MESSAGE = "message";
declare const APP_IMAGE = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCA0OTEgNDk2IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHRoZW1lPSJkYXJrIj48dGl0bGU+RnVlbCBXYWxsZXQgSWNvbjwvdGl0bGU+PHJlY3QgeD0iNDIuNTUzNSIgeT0iMjguMzQzOCIgd2lkdGg9IjM5Ny4xNTQiIGhlaWdodD0iNDI1LjE0MyIgZmlsbD0iIzA4MDgwOCI+PC9yZWN0PjxwYXRoIGQ9Ik0zMi42MTc4IDBDMTQuNTY5NyAwIDAgMTQuNzMyNyAwIDMyLjk4MjZWNDk2SDQwNS44NTJDNDE5LjU2OCA0OTYgNDMyLjc1OSA0OTAuNDkyIDQ0Mi40NzMgNDgwLjY3TDQ3NS4zNTMgNDQ3LjQyMkM0ODUuMDY2IDQzNy42IDQ5MC41MTMgNDI0LjI2MSA0OTAuNTEzIDQxMC4zOTFWMEgzMi42MTc4Wk0zMjAuMjcxIDYzLjc3NTJMMTYwLjcyNiAyMjUuMTA1QzE1Ni43ODggMjI5LjA4NiAxNTEuNDA3IDIzMS4zNDMgMTQ1LjgyOCAyMzEuMzQzQzEzNy42OSAyMzEuMzQzIDEzMC4yMDggMjI2LjU2NSAxMjYuNzMgMjE5LjEzMkw2NC45MDc0IDg3LjAwMjRDNTkuODUzOSA3Ni4xODUyIDY3LjY2MzggNjMuNzc1MiA3OS40NzcxIDYzLjc3NTJIMzIwLjI3MVpNNjMuMDY5NyA0MzIuMjI1VjI3NS4yNzVDNjMuMDY5NyAyNjYuOTE0IDY5Ljc2MzkgMjYwLjE0NSA3OC4wMzMyIDI2MC4xNDVIMjMzLjI0Nkw2My4wNjk3IDQzMi4yMjVaTTI0Ni4xMSAyMzEuMzQzSDE5NC43MjJMMzQ5LjM0NSA3NC45OTA2QzM1Ni40MzMgNjcuODIzNCAzNjYuMDggNjMuNzc1MiAzNzYuMTIxIDYzLjc3NTJINDI3LjUwOUwyNzIuODg3IDIyMC4xMjdDMjY1Ljc5OSAyMjcuMjk1IDI1Ni4xNTEgMjMxLjM0MyAyNDYuMTEgMjMxLjM0M1oiIGZpbGw9IiMwMEY1OEMiPjwvcGF0aD48L3N2Zz4=";

declare class FuelWalletConnector extends FuelConnector {
    name: string;
    connected: boolean;
    installed: boolean;
    external: boolean;
    events: typeof FuelConnectorEventTypes;
    metadata: ConnectorMetadata;
    readonly client: JSONRPCClient;
    constructor(name?: string);
    /**
     * ============================================================
     * Application communication methods
     * ============================================================
     */
    private setupConnector;
    private acceptMessage;
    private setupListener;
    private createRequestId;
    private postMessage;
    private sendRequest;
    private onResponse;
    private onEvent;
    private onMessage;
    private onCommunicationMessage;
    /**
     * ============================================================
     * Connector methods
     * ============================================================
     */
    ping(): Promise<boolean>;
    isConnected(): Promise<boolean>;
    connect(): Promise<boolean>;
    disconnect(): Promise<boolean>;
    accounts(): Promise<Array<string>>;
    currentAccount(): Promise<string | null>;
    signMessage(address: string, message: string): Promise<string>;
    sendTransaction(address: string, transaction: TransactionRequestLike, params?: FuelConnectorSendTxParams): Promise<string>;
    assets(): Promise<Array<Asset>>;
    addAsset(asset: Asset): Promise<boolean>;
    addAssets(assets: Asset[]): Promise<boolean>;
    addABI(contractId: string, abi: FuelABI): Promise<boolean>;
    getABI(contractId: string): Promise<FuelABI>;
    hasABI(contractId: string): Promise<boolean>;
    currentNetwork(): Promise<Network>;
    selectNetwork(network: SelectNetworkArguments): Promise<boolean>;
    networks(): Promise<Network[]>;
    addNetwork(networkUrl: string): Promise<boolean>;
    version(): Promise<Version>;
}

declare enum MessageTypes {
    ping = "ping",
    uiEvent = "uiEvent",
    event = "event",
    request = "request",
    response = "response",
    removeConnection = "removeConnection"
}
interface MessageSender {
    id?: string | undefined;
    origin?: string | undefined;
    tab?: {
        id?: number | undefined;
        index?: number | undefined;
        windowId?: number | undefined;
        url?: string | undefined;
        title?: string | undefined;
        favIconUrl?: string | undefined;
    };
}
type BaseEvent<T> = {
    readonly target: string;
    readonly connectorName?: string;
    readonly id?: string;
    readonly sender?: MessageSender;
} & T;
type EventMessageEvents = Array<{
    event: string;
    params: Array<unknown>;
}>;
type UIEventMessage = BaseEvent<{
    readonly type: MessageTypes.uiEvent;
    readonly ready: boolean;
    readonly session: string;
}>;
type RequestMessage = BaseEvent<{
    readonly type: MessageTypes.request;
    readonly request: JSONRPCRequest;
}>;
type ResponseMessage = BaseEvent<{
    readonly type: MessageTypes.response;
    readonly response: JSONRPCResponse;
}>;
type EventMessage<T = EventMessageEvents> = BaseEvent<{
    readonly type: MessageTypes.event;
    readonly events: T;
}>;
type CommunicationMessage = UIEventMessage | RequestMessage | ResponseMessage | EventMessage;

declare class FuelWalletDevelopmentConnector extends FuelWalletConnector {
    metadata: ConnectorMetadata;
    constructor();
}

declare class FueletWalletConnector extends FuelWalletConnector {
    name: string;
    metadata: ConnectorMetadata;
    constructor();
    currentAccount(): Promise<string | null>;
    isMobile(): boolean;
    isFueletWebView(): boolean;
    isMobileNativeBrowser(): boolean;
    connect(): Promise<boolean>;
    ping(): Promise<boolean>;
}

declare class RequestAPI {
    baseUrl: string;
    constructor(baseUrl: string);
    get(pathname: string): Promise<any>;
    delete(pathname: string): Promise<void>;
}

declare enum BakoSafeConnectorEvents {
    DEFAULT = "message",
    CLIENT_DISCONNECTED = "[CLIENT_DISCONNECTED]",
    CLIENT_CONNECTED = "[CONNECTED]",
    TX_PENDING = "[TX_EVENT_REQUESTED]",
    TX_CONFIRMED = "[TX_EVENT_CONFIRMED]",
    TX_TIMEOUT = "[TX_EVENT_TIMEOUT]",
    AUTH_CONFIRMED = "[AUTH_CONFIRMED]"
}
type BakoSafeConnectorConfig = {
    host?: string;
    appUrl?: string;
    storage?: StorageAbstract;
    api?: RequestAPI;
};

declare class BakoSafeConnector extends FuelConnector {
    name: string;
    metadata: {
        image: {
            light: string;
            dark: string;
        };
        install: {
            action: string;
            link: string;
            description: string;
        };
    };
    installed: boolean;
    connected: boolean;
    external: boolean;
    events: {
        connectors: FuelConnectorEventTypes.connectors;
        currentConnector: FuelConnectorEventTypes.currentConnector;
        connection: FuelConnectorEventTypes.connection;
        accounts: FuelConnectorEventTypes.accounts;
        currentAccount: FuelConnectorEventTypes.currentAccount;
        networks: FuelConnectorEventTypes.networks;
        currentNetwork: FuelConnectorEventTypes.currentNetwork;
        assets: FuelConnectorEventTypes.assets;
        abis: FuelConnectorEventTypes.abis;
        DEFAULT: BakoSafeConnectorEvents.DEFAULT;
        CLIENT_DISCONNECTED: BakoSafeConnectorEvents.CLIENT_DISCONNECTED;
        CLIENT_CONNECTED: BakoSafeConnectorEvents.CLIENT_CONNECTED;
        TX_PENDING: BakoSafeConnectorEvents.TX_PENDING;
        TX_CONFIRMED: BakoSafeConnectorEvents.TX_CONFIRMED;
        TX_TIMEOUT: BakoSafeConnectorEvents.TX_TIMEOUT;
        AUTH_CONFIRMED: BakoSafeConnectorEvents.AUTH_CONFIRMED;
    };
    private readonly appUrl;
    private readonly host;
    private readonly api;
    private setupReady?;
    private socket?;
    private sessionId?;
    private dAppWindow?;
    private storage?;
    constructor(config?: BakoSafeConnectorConfig);
    private getStorage;
    private getSessionId;
    private checkWindow;
    /**
     * [important]
     * this.socket.emit -> emit message to the server
     * this.emit -> emit message to the dApp client
     */
    private setup;
    connect(): Promise<boolean>;
    sendTransaction(_address: string, _transaction: TransactionRequestLike): Promise<string>;
    ping(): Promise<boolean>;
    version(): Promise<{
        app: string;
        network: string;
    }>;
    isConnected(): Promise<any>;
    accounts(): Promise<any[]>;
    currentAccount(): Promise<any>;
    disconnect(): Promise<boolean>;
    currentNetwork(): Promise<Network>;
    networks(): Promise<Array<Network>>;
    assets(): Promise<Asset[]>;
    signMessage(_address: string, _message: string): Promise<string>;
    addAssets(_assets: Asset[]): Promise<boolean>;
    addAsset(_assets: Asset): Promise<boolean>;
    addNetwork(_networkUrl: string): Promise<boolean>;
    selectNetwork(_network: SelectNetworkArguments): Promise<boolean>;
    addABI(_contractId: string, _abi: FuelABI): Promise<boolean>;
    getABI(_id: string): Promise<FuelABI | null>;
    hasABI(_id: string): Promise<boolean>;
}

type WalletConnectConfig = {
    fuelProvider?: Provider | Promise<Provider>;
    projectId?: string;
    wagmiConfig?: Config;
    predicateConfig?: PredicateConfig;
    storage?: StorageAbstract;
    chainId?: number;
    skipAutoReconnect?: boolean;
};
interface CustomCurrentConnectorEvent extends ConnectorEvent {
    metadata: {
        pendingSignature: boolean;
    };
}

declare class WalletConnectConnector extends PredicateConnector {
    name: string;
    installed: boolean;
    events: typeof FuelConnectorEventTypes;
    metadata: ConnectorMetadata;
    private fuelProvider;
    private ethProvider;
    private web3Modal;
    private storage;
    private config;
    constructor(config: WalletConnectConfig);
    private loadPersistedConnection;
    private createModal;
    private modalFactory;
    private handleConnect;
    private setupWatchers;
    protected getWagmiConfig(): Maybe<Config>;
    protected getWalletAdapter(): PredicateWalletAdapter;
    protected getPredicateVersions(): Record<string, PredicateVersion>;
    protected configProviders(config?: WalletConnectConfig): Promise<void>;
    protected walletAccounts(): Promise<Array<string>>;
    protected getAccountAddress(): Promise<Maybe<string>>;
    protected getAccountAddresses(): Promise<Maybe<readonly string[]>>;
    protected requireConnection(): Promise<void>;
    protected getProviders(): Promise<ProviderDictionary>;
    connect(): Promise<boolean>;
    private getAccountValidations;
    private accountHasValidation;
    private requestSignatures;
    private requestSignature;
    disconnect(): Promise<boolean>;
    sendTransaction(address: string, transaction: TransactionRequestLike, params?: FuelConnectorSendTxParams): Promise<string>;
    private isValidPredicateAddress;
    private encodeTxId;
    private validateSignature;
    private signAndValidate;
    signMessageCustomCurve(message: string): Promise<{
        curve: string;
        signature: string;
    }>;
    static getFuelPredicateAddresses(ethAddress: string): {
        fuelAddress: `0x${string}`;
        evmPredicate: {
            generatedAt: 1738383921738 | 1728253389401 | 1725479113004;
            address: string;
        };
    }[];
}

declare function subscribeAndEnforceChain(config: Config): void;

type SolanaConfig = {
    fuelProvider?: Provider | Promise<Provider>;
    projectId?: string;
    predicateConfig?: PredicateConfig;
    solanaConfig?: ProviderType;
    chainId?: number;
};
interface GetAccounts {
    id: string;
    jsonrpc: string;
    result: {
        pubkey: string;
    }[];
}
declare enum SolanaChains {
    MAINNET = "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
    DEVNET = "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
    TESTNET = "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z"
}
declare enum SolanaMethods {
    GET_ACCOUNTS = "solana_getAccounts",
    SIGN_TRANSACTION = "solana_signTransaction",
    SIGN_MESSAGE = "solana_signMessage",
    REQUEST_ACCOUNTS = "solana_requestAccounts"
}
declare enum SolanaEvents {
    DISPLAY_URI = "display_uri",
    SESSION_PING = "session_ping",
    SESSION_EVENT = "session_event",
    SESSION_UPDATE = "session_update",
    SESSION_DELETE = "session_delete"
}

declare class SolanaConnector extends PredicateConnector {
    name: string;
    events: typeof FuelConnectorEventTypes;
    metadata: ConnectorMetadata;
    protected fuelProvider: Provider;
    private web3Modal;
    private config;
    private svmAddress;
    constructor(config: SolanaConfig);
    private _emitDisconnect;
    private _emitConnected;
    private modalFactory;
    private providerFactory;
    private setupWatchers;
    private createModal;
    protected requireConnection(): Promise<void>;
    protected getWalletAdapter(): PredicateWalletAdapter;
    protected getPredicateVersions(): Record<string, PredicateVersion>;
    protected configProviders(config?: SolanaConfig): Promise<void>;
    protected walletAccounts(): Promise<Array<string>>;
    protected getAccountAddress(): Maybe<string>;
    protected getProviders(): Promise<ProviderDictionary>;
    connect(): Promise<boolean>;
    disconnect(): Promise<boolean>;
    private encodeTxId;
    sendTransaction(address: string, transaction: TransactionRequestLike): Promise<string>;
    signMessageCustomCurve(message: string): Promise<{
        curve: string;
        signature: string;
    }>;
    static getFuelPredicateAddresses(svmAddress: string): {
        fuelAddress: `0x${string}`;
        svmPredicate: {
            generatedAt: 1725561405784 | 1728255070813;
            address: string;
        };
    }[];
}

export { APP_IMAGE, BakoSafeConnector, type BurnerWalletConfig, BurnerWalletConnector, CONNECTOR_SCRIPT, CONTENT_SCRIPT_NAME, type CommunicationMessage, type CustomCurrentConnectorEvent, EVENT_MESSAGE, type EventMessage, type EventMessageEvents, FuelWalletConnector, FuelWalletDevelopmentConnector, FueletWalletConnector, type GetAccounts, type MessageSender, MessageTypes, type RequestMessage, type ResponseMessage, SolanaChains, type SolanaConfig, SolanaConnector, SolanaEvents, SolanaMethods, type UIEventMessage, type WalletConnectConfig, WalletConnectConnector, createConfig, defaultConnectors, hasSignMessageCustomCurve, subscribeAndEnforceChain };
