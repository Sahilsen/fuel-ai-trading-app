import { type B256Address, type BN, type BytesLike, type InputValue, Predicate, type Provider } from 'fuels';
import memoize from 'memoizee';
import type { PredicateWalletAdapter } from './PredicateWalletAdapter';
import type { Maybe, PredicateConfig } from './types';
export declare class PredicateFactory {
    private abi;
    private bytecode;
    private adapter;
    private root;
    private generatedAt;
    constructor(adapter: PredicateWalletAdapter, { abi, bin }: PredicateConfig, root: string, generatedAt?: number);
    getRoot: () => string;
    getPredicateAddress: ((address: string | B256Address) => string) & memoize.Memoized<(address: string | B256Address) => string>;
    build: (<T extends InputValue[]>(address: string | B256Address, provider: Provider, data?: T) => Predicate<T>) & memoize.Memoized<(<T extends InputValue[]>(address: string | B256Address, provider: Provider, data?: T) => Predicate<T>)>;
    getAccountAddress: (address: string, accounts?: Array<string>) => Maybe<string>;
    getPredicateAddresses: (accounts?: Array<string>) => Array<string>;
    getMaxPredicateGasUsed: ((provider: Provider) => Promise<BN>) & memoize.Memoized<(provider: Provider) => Promise<BN>>;
    equals: (predicate: Maybe<PredicateFactory>) => boolean;
    sort: (predicate: PredicateFactory) => number;
}
/**
 * Since the predicate resources were fetched and added to the TransactionRequest before the predicate
 * was instantiated, it is very likely that they were fetched and added as normal account resources,
 * resulting in a witness placeholder being added to the witnesses of the TransactionRequest to
 * later be replaced with an actual signature. Since predicate resources do not require a signature,
 * this placeholder witness will be removed when calling `Predicate.populateTransactionPredicateData`.
 * However, we need to validate if this placeholder witness was added here in order to instantiate the
 * predicate with the correct witness index argument.
 */
export declare const getMockedSignatureIndex: (witnesses: BytesLike[]) => number;
