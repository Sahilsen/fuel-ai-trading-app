import { type AbiMap, type Asset, type BytesLike, type ConnectorMetadata, FuelConnector, FuelConnectorEventTypes, type JsonAbi, type Network, type SelectNetworkArguments, type TransactionRequestLike, type Version } from 'fuels';
import { PredicateFactory } from './PredicateFactory';
import type { PredicateWalletAdapter } from './PredicateWalletAdapter';
import type { ConnectorConfig, Maybe, MaybeAsync, PredicateConfig, PredicateVersion, PreparedTransaction, ProviderDictionary, SignedMessageCustomCurve } from './types';
export declare abstract class PredicateConnector extends FuelConnector {
    connected: boolean;
    installed: boolean;
    external: boolean;
    events: typeof FuelConnectorEventTypes;
    protected predicateAddress: string;
    protected customPredicate: Maybe<PredicateConfig>;
    protected predicateAccount: Maybe<PredicateFactory>;
    protected subscriptions: Array<() => void>;
    protected hasProviderSucceeded: boolean;
    private _predicateVersions;
    abstract name: string;
    abstract metadata: ConnectorMetadata;
    abstract sendTransaction(address: string, transaction: TransactionRequestLike): Promise<string>;
    abstract connect(): Promise<boolean>;
    abstract disconnect(): Promise<boolean>;
    protected abstract configProviders(config: ConnectorConfig): MaybeAsync<void>;
    protected abstract getWalletAdapter(): PredicateWalletAdapter;
    protected abstract getPredicateVersions(): Record<string, PredicateVersion>;
    protected abstract getAccountAddress(): MaybeAsync<Maybe<string>>;
    protected abstract getProviders(): Promise<ProviderDictionary>;
    protected abstract requireConnection(): MaybeAsync<void>;
    protected abstract walletAccounts(): Promise<Array<string>>;
    abstract signMessageCustomCurve(_message: string): Promise<SignedMessageCustomCurve>;
    protected emitAccountChange(address: string, connected?: boolean): Promise<void>;
    protected get predicateVersions(): Array<PredicateFactory>;
    protected isAddressPredicate(b: BytesLike, walletAccount: string): boolean;
    protected getCurrentUserPredicate(): Promise<Maybe<PredicateFactory>>;
    protected getNewestPredicate(): Maybe<PredicateFactory>;
    protected setupPredicate(): Promise<PredicateFactory>;
    protected subscribe(listener: () => void): void;
    protected prepareTransaction(address: string, transaction: TransactionRequestLike): Promise<PreparedTransaction>;
    clearSubscriptions(): void;
    ping(): Promise<boolean>;
    version(): Promise<Version>;
    isConnected(): Promise<boolean>;
    accounts(): Promise<Array<string>>;
    currentAccount(): Promise<string | null>;
    networks(): Promise<Network[]>;
    currentNetwork(): Promise<Network>;
    signMessage(_address: string, _message: string): Promise<string>;
    addAssets(_assets: Asset[]): Promise<boolean>;
    addAsset(_asset: Asset): Promise<boolean>;
    assets(): Promise<Array<Asset>>;
    addNetwork(_networkUrl: string): Promise<boolean>;
    selectNetwork(_network: SelectNetworkArguments): Promise<boolean>;
    addAbi(_abiMap: AbiMap): Promise<boolean>;
    getAbi(_contractId: string): Promise<JsonAbi>;
    hasAbi(_contractId: string): Promise<boolean>;
}
