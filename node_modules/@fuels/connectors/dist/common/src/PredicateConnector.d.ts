import { type AbiMap, type Asset, type BytesLike, type ConnectorMetadata, FuelConnector, FuelConnectorEventTypes, type HashableMessage, type JsonAbi, type Network, type SelectNetworkArguments, type TransactionRequestLike, type TransactionResponse, type Version } from 'fuels';
import { PredicateFactory } from './PredicateFactory';
import type { PredicateWalletAdapter } from './PredicateWalletAdapter';
import type { ConnectorConfig, Maybe, MaybeAsync, PredicateConfig, PredicateVersion, PredicateVersionWithMetadata, PreparedTransaction, ProviderDictionary, SignedMessageCustomCurve } from './types';
export declare abstract class PredicateConnector extends FuelConnector {
    connected: boolean;
    installed: boolean;
    external: boolean;
    events: typeof FuelConnectorEventTypes;
    protected predicateAddress: string;
    protected customPredicate: Maybe<PredicateConfig>;
    protected predicateAccount: Maybe<PredicateFactory>;
    protected subscriptions: Array<() => void>;
    protected hasProviderSucceeded: boolean;
    protected selectedPredicateVersion: Maybe<string>;
    private _predicateVersions;
    abstract name: string;
    abstract metadata: ConnectorMetadata;
    abstract sendTransaction(address: string, transaction: TransactionRequestLike): Promise<string | TransactionResponse>;
    abstract connect(): Promise<boolean>;
    /**
     * Derived classes MUST call `await super.disconnect();` as part of their
     * disconnection logic. They remain responsible for their specific
     * disconnection procedures (e.g., from the underlying wallet),
     * updating `this.connected` status, and emitting events such as
     * `connection`, `currentAccount`, and `accounts`.
     * @returns A promise that resolves to true if the base cleanup is successful.
     */
    disconnect(): Promise<boolean>;
    protected abstract configProviders(config: ConnectorConfig): MaybeAsync<void>;
    protected abstract getWalletAdapter(): PredicateWalletAdapter;
    protected abstract getPredicateVersions(): Record<string, PredicateVersion>;
    protected abstract getAccountAddress(): MaybeAsync<Maybe<string>>;
    protected abstract getProviders(): Promise<ProviderDictionary>;
    protected abstract requireConnection(): MaybeAsync<void>;
    protected abstract walletAccounts(): Promise<Array<string>>;
    abstract signMessageCustomCurve(_message: string): Promise<SignedMessageCustomCurve>;
    constructor();
    protected emitAccountChange(address: string, connected?: boolean): Promise<void>;
    protected get predicateVersions(): Array<PredicateFactory>;
    getAvailablePredicateVersions(): Array<{
        id: string;
        generatedAt: number;
    }>;
    /**
     * Get all predicate versions including metadata
     * @returns Promise that resolves to the array of predicate versions with complete metadata
     */
    getAllPredicateVersionsWithMetadata(): Promise<PredicateVersionWithMetadata[]>;
    setSelectedPredicateVersion(versionId: string): void;
    getSelectedPredicateVersion(): Maybe<string>;
    getSmartDefaultPredicateVersion(): Promise<Maybe<string>>;
    switchPredicateVersion(versionId: string): Promise<void>;
    protected isAddressPredicate(b: BytesLike, walletAccount: string): boolean;
    protected getCurrentUserPredicate(): Promise<Maybe<PredicateFactory>>;
    protected getNewestPredicate(): Maybe<PredicateFactory>;
    protected getPredicateByVersion(versionId: string): Maybe<PredicateFactory>;
    protected setupPredicate(): Promise<PredicateFactory>;
    protected subscribe(listener: () => void): void;
    protected prepareTransaction(address: string, transaction: TransactionRequestLike): Promise<PreparedTransaction>;
    clearSubscriptions(): void;
    ping(): Promise<boolean>;
    version(): Promise<Version>;
    isConnected(): Promise<boolean>;
    accounts(): Promise<Array<string>>;
    currentAccount(): Promise<string | null>;
    networks(): Promise<Network[]>;
    currentNetwork(): Promise<Network>;
    signMessage(_address: string, _message: HashableMessage): Promise<string>;
    addAssets(_assets: Asset[]): Promise<boolean>;
    addAsset(_asset: Asset): Promise<boolean>;
    assets(): Promise<Array<Asset>>;
    addNetwork(_networkUrl: string): Promise<boolean>;
    selectNetwork(_network: SelectNetworkArguments): Promise<boolean>;
    addAbi(_abiMap: AbiMap): Promise<boolean>;
    getAbi(_contractId: string): Promise<JsonAbi>;
    hasAbi(_contractId: string): Promise<boolean>;
}
